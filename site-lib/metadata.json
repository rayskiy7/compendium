{"createdTime":1767017200423,"shownInTree":["kernighan-&-ritchie-‚Äî-c-pl.html","start-page.html","stroustrup-b./tc++pl.-tome-1.html","stroustrup-b./tc++pl.-tome-2.html"],"attachments":["site-lib/fonts/94f2f163d4b698242fef.otf","site-lib/fonts/72505e6a122c6acd5471.woff2","site-lib/fonts/2d5198822ab091ce4305.woff2","site-lib/fonts/c8ba52b05a9ef10f4758.woff2","site-lib/fonts/cb10ffd7684cd9836a05.woff2","site-lib/fonts/293fd13dbca5a3e450ef.woff2","site-lib/fonts/085cb93e613ba3d40d2b.woff2","site-lib/fonts/b5f0f109bc88052d4000.woff2","site-lib/fonts/cbe0ae49c52c920fd563.woff2","site-lib/fonts/535a6cf662596b3bd6a6.woff2","site-lib/fonts/70cc7ff27245e82ad414.ttf","site-lib/fonts/454577c22304619db035.ttf","site-lib/fonts/52ac8f3034507f1d9e53.ttf","site-lib/fonts/05b618077343fbbd92b7.ttf","site-lib/fonts/4bb6ac751d1c5478ff3a.woff2","site-lib/media/6155340132a851f6089e.svg","site-lib/media/2308ab1944a6bfa5c5b8.svg","site-lib/fonts/mathjax_zero.woff","site-lib/fonts/mathjax_main-regular.woff","site-lib/fonts/mathjax_main-bold.woff","site-lib/fonts/mathjax_math-italic.woff","site-lib/fonts/mathjax_main-italic.woff","site-lib/fonts/mathjax_math-bolditalic.woff","site-lib/fonts/mathjax_size1-regular.woff","site-lib/fonts/mathjax_size2-regular.woff","site-lib/fonts/mathjax_size3-regular.woff","site-lib/fonts/mathjax_size4-regular.woff","site-lib/fonts/mathjax_ams-regular.woff","site-lib/fonts/mathjax_calligraphic-regular.woff","site-lib/fonts/mathjax_calligraphic-bold.woff","site-lib/fonts/mathjax_fraktur-regular.woff","site-lib/fonts/mathjax_fraktur-bold.woff","site-lib/fonts/mathjax_sansserif-regular.woff","site-lib/fonts/mathjax_sansserif-bold.woff","site-lib/fonts/mathjax_sansserif-italic.woff","site-lib/fonts/mathjax_script-regular.woff","site-lib/fonts/mathjax_typewriter-regular.woff","site-lib/fonts/mathjax_vector-regular.woff","site-lib/fonts/mathjax_vector-bold.woff","site-lib/html/file-tree-content.html","site-lib/scripts/webpage.js","site-lib/media/favicon.png","site-lib/styles/snippets.css","site-lib/styles/obsidian.css","site-lib/styles/other-plugins.css","site-lib/styles/global-variable-styles.css","site-lib/styles/supported-plugins.css","site-lib/styles/main-styles.css","a9s/screenshot-2025-10-04-at-04.41.40.png","a9s/screenshot-2025-10-04-at-20.06.24.png","a9s/screenshot-2025-10-05-at-01.00.15.png","a9s/screenshot-2025-10-05-at-05.47.03.png","a9s/screenshot-2025-10-05-at-18.26.55.png","a9s/screenshot-2025-10-05-at-18.27.27.png","a9s/screenshot-2025-10-07-at-03.03.28.png","a9s/screenshot-2025-10-11-at-19.25.32.png","a9s/screenshot-2025-09-27-at-22.49.48.png","a9s/screenshot-2025-09-20-at-01.48.06.png","a9s/screenshot-2025-09-20-at-13.23.06.png","a9s/screenshot-2025-09-20-at-15.44.51.png","a9s/screenshot-2025-09-25-at-02.53.33.png","a9s/screenshot-2025-09-29-at-04.15.37.png","a9s/screenshot-2025-09-29-at-15.56.15.png","a9s/screenshot-2025-10-01-at-02.55.34.png","a9s/screenshot-2025-10-01-at-02.56.03.png","a9s/screenshot-2025-10-02-at-01.51.27.png","a9s/screenshot-2025-10-02-at-23.54.37.png","site-lib/rss.xml"],"allFiles":["start-page.html","stroustrup-b./tc++pl.-tome-2.html","kernighan-&-ritchie-‚Äî-c-pl.html","stroustrup-b./tc++pl.-tome-1.html","a9s/screenshot-2025-10-11-at-19.25.32.png","a9s/screenshot-2025-10-07-at-03.03.28.png","a9s/screenshot-2025-10-05-at-18.27.27.png","a9s/screenshot-2025-10-05-at-18.26.55.png","a9s/screenshot-2025-10-05-at-05.47.03.png","a9s/screenshot-2025-10-05-at-01.00.15.png","a9s/screenshot-2025-10-04-at-20.06.24.png","a9s/screenshot-2025-10-04-at-04.41.40.png","a9s/screenshot-2025-10-02-at-23.54.37.png","a9s/screenshot-2025-10-02-at-01.51.27.png","a9s/screenshot-2025-10-01-at-02.56.03.png","a9s/screenshot-2025-10-01-at-02.55.34.png","a9s/screenshot-2025-09-29-at-15.56.15.png","a9s/screenshot-2025-09-29-at-04.15.37.png","a9s/screenshot-2025-09-27-at-22.49.48.png","a9s/screenshot-2025-09-25-at-02.53.33.png","a9s/screenshot-2025-09-20-at-15.44.51.png","a9s/screenshot-2025-09-20-at-13.23.06.png","a9s/screenshot-2025-09-20-at-01.48.06.png","site-lib/fonts/94f2f163d4b698242fef.otf","site-lib/fonts/72505e6a122c6acd5471.woff2","site-lib/fonts/2d5198822ab091ce4305.woff2","site-lib/fonts/c8ba52b05a9ef10f4758.woff2","site-lib/fonts/cb10ffd7684cd9836a05.woff2","site-lib/fonts/293fd13dbca5a3e450ef.woff2","site-lib/fonts/085cb93e613ba3d40d2b.woff2","site-lib/fonts/b5f0f109bc88052d4000.woff2","site-lib/fonts/cbe0ae49c52c920fd563.woff2","site-lib/fonts/535a6cf662596b3bd6a6.woff2","site-lib/fonts/70cc7ff27245e82ad414.ttf","site-lib/fonts/454577c22304619db035.ttf","site-lib/fonts/52ac8f3034507f1d9e53.ttf","site-lib/fonts/05b618077343fbbd92b7.ttf","site-lib/fonts/4bb6ac751d1c5478ff3a.woff2","site-lib/media/6155340132a851f6089e.svg","site-lib/media/2308ab1944a6bfa5c5b8.svg","site-lib/fonts/mathjax_zero.woff","site-lib/fonts/mathjax_main-regular.woff","site-lib/fonts/mathjax_main-bold.woff","site-lib/fonts/mathjax_math-italic.woff","site-lib/fonts/mathjax_main-italic.woff","site-lib/fonts/mathjax_math-bolditalic.woff","site-lib/fonts/mathjax_size1-regular.woff","site-lib/fonts/mathjax_size2-regular.woff","site-lib/fonts/mathjax_size3-regular.woff","site-lib/fonts/mathjax_size4-regular.woff","site-lib/fonts/mathjax_ams-regular.woff","site-lib/fonts/mathjax_calligraphic-regular.woff","site-lib/fonts/mathjax_calligraphic-bold.woff","site-lib/fonts/mathjax_fraktur-regular.woff","site-lib/fonts/mathjax_fraktur-bold.woff","site-lib/fonts/mathjax_sansserif-regular.woff","site-lib/fonts/mathjax_sansserif-bold.woff","site-lib/fonts/mathjax_sansserif-italic.woff","site-lib/fonts/mathjax_script-regular.woff","site-lib/fonts/mathjax_typewriter-regular.woff","site-lib/fonts/mathjax_vector-regular.woff","site-lib/fonts/mathjax_vector-bold.woff","site-lib/html/file-tree-content.html","site-lib/scripts/webpage.js","site-lib/media/favicon.png","site-lib/styles/snippets.css","site-lib/styles/obsidian.css","site-lib/styles/other-plugins.css","site-lib/styles/global-variable-styles.css","site-lib/styles/supported-plugins.css","site-lib/styles/main-styles.css"],"webpages":{"kernighan-&-ritchie-‚Äî-c-pl.html":{"title":"Kernighan & Ritchie ‚Äî C PL","icon":"","description":"\nShould to note: C is not a strongly-typed, but still has type-checking! Earlier, you mustn't to explicitly interchange of pointers and integers, but now you must! Some operators have the wrong precedence!\n#include &lt;stdio.h&gt; int main()\n{\nprintf(\"hello, world!\\n\");\n}\nC programm:\nfunctions statements variables\nPlay with arithmetic:#include &lt;stdio.h&gt; // inline comment\n/* multiline comment */ int main(){ float f, c; int lower, upper, step; lower = 0; upper = 300; step = 20; f = lower; while (f &lt;= upper){ c = (5.0/9.0) * (f-32.0); printf(\"%3.0f %6.1f\\n\", f, c); f = f + step; }\n} int division truncates\nAvailable types:\nint, float, char, short, long, double\nwhile kinds:\nsingle statement: while (&lt;condition&gt;) &lt;statement&gt;;\nmany statements: while (&lt;condition&gt;) {&lt;statement 1&gt;; &lt;statement 2&gt;; ...}\narithmetic way depends on operand types:\nall integers -&gt; integer operation\nat least one float -&gt; convert ints to floats and float operation\ntest it:\n#include &lt;stdio.h&gt; int main(){ printf(\"%d\\n\", 1/2); printf(\"%f\\n\", 1.0/2); printf(\"%f\\n\", 1.0/2.0);\n}\nsome formatted output specs:\n%d - for int\n%ld - for long\n%f - for float and double\n%e - scientific notation of float\n%g - general notation of float\n%o - for octal\n%x - for hexadecimal\n%c - for character\n%s - for character string\n%% - for %-sign\n%p - for pointers\nDetails directly from the book:\nformat of conversion: %[-][5][.][7][h/l]?, where ? is special character:\n<img alt=\"Screenshot 2025-09-27 at 22.49.48.png\" src=\"a9s/screenshot-2025-09-27-at-22.49.48.png\" target=\"_self\" style=\"width: 500px; max-width: 100%;\">\nWidth and precision can be set by int value:\nprintf(\"%.*f\", prec, floatval);There is an alternative version that prints in another string:1int sprintf(char *resstr, char *format, arg1, arg2, ...);\nAll parts of for loop can be any expressions\nPreprocessor directives:1#include23#define4\t#5\t##6\t... and __VA_ARGS__7#undef89#if10#ifdef11#ifndef12#elif13#else14#endif1516#error17#warning18#line19#pragma2021#Predefined macros:1__FILE__2__LINE__3__DATE__4__TIME__56__func__7__STDC__8__STDC_VERSION__Directive #define doesn't replace NAME in quotes nor as part of another name.First step io functions:\ngetchar\nputchar\nthey work with int\nExercise \"char counts\":1#include &lt;stdio.h&gt;2#define CHARS_COUNT 25634int main(){5\tchar text[] = \"hello world my dear man!\";6\tint chars[CHARS_COUNT];7\tfor(int i=0; i&lt;CHARS_COUNT; i++)8 chars[i]=0;910\tfor(int i=0; i&lt;sizeof(text); i++)11 chars[text[i]]++;12\tfor(int i=0; i&lt;CHARS_COUNT; i++)13 if (chars[i] !=0)14 printf(\"%c(%d) ‚Äî %d\\n\",i,i,chars[i]);15}Used convention:\nparameter (formal argument) ‚Äî for variable in function declaration/definition\nargument (actual argument) ‚Äî for in call\nSome info about parameter names:1int power(int, int); // just declaration or function prototype2int main(){3\t// some use of power(m, n);4}5int func(int base, int exponent){6\t// definition...7}Attention!\nStrings end with \\0 symbol!\n<br>Exercise \"max line length, but max 50 symbols to show\": <a data-tooltip-position=\"top\" aria-label=\"file:///Users/rayskiy7/dev/new_beginning/c/KR/longest_line.c\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"file:/Users/rayskiy7/dev/new_beginning/c/KR/longest_line.c\" target=\"_self\">–û—Ç–∫—Ä—ã—Ç—å —Ñ–∞–π–ª</a>Automatic variables ‚Äî term for local function variables.Available to set void in params list. Indeed, they must do so for explicit indication for compiler to check your calls of this function1int myfunc (void) // &lt;- !2{...}34int main()5{6\tmyfunc(); // can't be called without arguments7}Explicit declaration of global variable:1int main()2{3\textern int x;4}It's possible to omit extern if global var defined in this file:1#include &lt;stdio.h&gt;2int x=77;34int main()5{6\t// omitted: extern int x;7\tprintf(\"%d\\n\", x);8}Don't use more than 31 symbol for names in C, it may cause problems for linking in older systems.Basic types:\nchar, short, int, long, long long, float, double, long double.\nInteger types can be provided with signed or unsigned.Standard says: 8 ‚â§ char, 16 ‚â§ short ‚â§ int ‚â§ long ‚â§ long long, 32 ‚â§ long.Any suffixes and their types:1\tint x = 1234;2\tlong x = 1234L;3\tunsigned long x = 1234UL;4\tfloat x = 12.3f, y = 12e-3f;5\tdouble x = 3.4;6\tlong double = 3.4L;RunOctals and hexs:1int x = 010; // 8 (_10)2int x = 0xB; // 11 (_10)3unsigned long x = 0xFul;RunAll escape sequences:<br>\n<img alt=\"Screenshot 2025-09-20 at 01.48.06.png\" src=\"a9s/screenshot-2025-09-20-at-01.48.06.png\" target=\"_self\">Concatenation is automatic:\n\"conca\" \"tenation\" == \"concatenation\"Important!1\t\"hello\" == char[6]{'h', 'e', 'l', 'l', 'o', '\\0'}Run1enum months{JAN=1, FEB, MAR}; // autoincrements!2MAR == 3RunNames in different enums must be unique, but inner values in the same enum must not.\nAlso unnamed enums are valid:1enum {GREEN, RED, BLUE};Run\nExternal and static variables must be initialized once before program starts. With constant expression! Local variables is initialized on function call with expression.\nExternals/static has 0 as default value. But locals has not!\nConstants:1const double e = 2.71828182845905;2const char msg[] = \"warning: \";34int strlen(const char message[]){...};RunRules only for signed operands, auto type conversions:<br>\n<img alt=\"Screenshot 2025-09-20 at 13.23.06.png\" src=\"a9s/screenshot-2025-09-20-at-13.23.06.png\" target=\"_self\">Type conversion rules with unsigned is more complicated, because comparisons between signed/unsigned are machine-dependent. For example:1-1L &lt; 1U; // so 1U i-&gt;L2-1L &gt; 1UL; // so -1L L-&gt;ULRunFor function calls, when it doesn't have prototype (declaration with args), there are any more auto convertions:\nchar, short ‚Äî&gt; int\nfloat ‚Äî&gt; double\n<br>See exercises with strings: <a data-tooltip-position=\"top\" aria-label=\"file:///Users/rayskiy7/dev/new_beginning/c/KR/htoi.c\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"file:/Users/rayskiy7/dev/new_beginning/c/KR/htoi.c\" target=\"_self\">htoi</a> and <a data-tooltip-position=\"top\" aria-label=\"file:///Users/rayskiy7/dev/new_beginning/c/KR/squeeze.c\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"file:/Users/rayskiy7/dev/new_beginning/c/KR/squeeze.c\" target=\"_self\">sqeeze</a>.\nRight bitwise shift of signed value fills with sign bits or 0-bits in machine-dependent way! For op= operator left-hand expression computes only once\n1-bits count is faster with:\nx &amp;= (x-1), which delete rightmost 1-bit!\nType of ?:-expression is determined by the conversion rules. Be careful about order of computing different operand. For example in x = f() + g() there is no determined order in which functions are called!\nAnd one more example is:\n1f(n++, n*2); // wrong! There is no determined order for args evalRunOperators precedence:<br>\n<img alt=\"Screenshot 2025-09-20 at 15.44.51.png\" src=\"a9s/screenshot-2025-09-20-at-15.44.51.png\" target=\"_self\">\nAnd shortcut:\nbraces and attributes\nunary\nnotbin arithmetic\nshifts\ncomparison\nbin arithmetic\nboolean\nternary ?:\nassignment\ncomma-op\nIf-else association:1if (...)2\tif (...) // &lt;- second if3 statement_1;4\telse // refers to second if5 statement_2;RunRight associativity:1x = cond1 ? (cond2 ? expr1 : expr2) : expr3;2y = cond1 ? expr1 : (cond2 ? expr2 : expr3);RunGood practice\nAdd break; even in default section of switch\nswitch:1switch(expression){2case 1: case 2:3\tstatements;4case 3:5\tstatement;6\tbreak;7default:8\tstatement;9\tbreak;10}Run<br>See exercise <a data-tooltip-position=\"top\" aria-label=\"file:///Users/rayskiy7/dev/new_beginning/c/KR/escapes.c\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"file:/Users/rayskiy7/dev/new_beginning/c/KR/escapes.c\" target=\"_self\">escapes</a>.Comma operator (parenthesis are required due = precedence is more than ,-precedence):1/* isn't for prod */23int x;4x = (2, 3.4, 7); // x becomes int 7RunMay use good practice:1do { // use braces for hastly reader of your code!2\tonly one statement;3} while (condition);Rungoto:1void func()2{3\tgoto label; // label must be in this func block4\t5\tlabel: // scopes this func block6\tstatements;7}RunRemainder: functions earlier was declared without params. And default return type was int.warning, but possible:1int f(){2\t// no return statement3} // returns garbageRunThere is possibility to declare external function right in local scope of another function:1void f()2{3\tint sum(int, int), sub(int, int);4\tsum(1, 2);5}Runif func defined as:1// file: funcs.c23double func(){...}Runand used as:1// file: program.c23int main()4{5\tint func();6\tint x = func();7}Run\nThen func will be called with implicit type reinterpretation double-&gt;int. It's possible and dangerous!\nAttention!\n3.1234 will interpreted as 1078523464\nIt's just treat double bits as int\n2 more risky moments:\nIf there is no explicit declaration but calling some symbol like x = somefunc(int_a, int_b); compiler think somefunc returns int and worse of that, somefunc treat int_a and int_b with just type reinterpretation (type punning).\ndeclaration float func() is unknown params func, and onlyfloat func(void) is valid way!\nInteresting moment from Polish calculator program:1switch(type){2case '+':3\tpush(pop()+pop());4\tbreak;5case '-':6\top2=pop();7\tpush(pop()-op2);8\tbreak;9...10}RunTake attention at order for pop() and pop(): in 7'th line we can't use (pop()-pop()).<br>See the example with <a data-tooltip-position=\"top\" aria-label=\"file:///Users/rayskiy7/dev/new_beginning/c/KR/ch4/stack.c\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"file:/Users/rayskiy7/dev/new_beginning/c/KR/ch4/stack.c\" target=\"_self\">stack</a>. There are extern variables.For extern array declaration we usually don't use the size inside brackets:1extern int sp;2extern double stack[]; // there is no size, indeed it's optionalRunImportant!\nThere is a tradeoff between the desire that each file have access only to the information it need for its job and the pactical reality that it is harder to maintain more header files.\nThus, one .h is used by any files, and by user's code and your library realization.\nAll modifiers:\nstorage class specifiers auto (outdated)\nextern\nstatic\nregister type qualifiers (may be inserted after *: int *const var;) const\nvolatile\nrestrict function specifiers extern\nstatic\ninline It's possible to mark function params and automatic variables with register to advise the compiler to place var in machine registers.But\nCompilers are free to ignore that advice.\nExample:1int func(register int a, int b)2{3\tregister float f;4}RunFor register-marked vars:\nonly some types and numbers of variable can be register (machine-dependent)\nIt's NOT possible to take the address of register variable\nYou can declare and initialize variables in nested blocks, compiler move it declaration on top of enclosing function or optimize, but doesn't access any by scope rules. Example:1int func(){2\tint i=0; // indeed `j` may be created here, or with `i` reuse3\tfor (int j=1; j&lt;5; j++){ // j can be accessed only in `for` body4 &lt;print(j)&gt;;5 // can access `i`6\t}7\t// can't access `j`, but it may be still alive8}RunAutomatic Initialization, when there is no declare+init statement.\nStatic and extern ‚Äî autoinit with 0\nAuto and register ‚Äî undefined (i.e., garbage)\nFor static:1static int a=7; // [const!] inited on start wherever it is23int func(){4\tif (condition){5 static int b=dinamicval(); // (C99+) [dyn!] inited6 ... // at this line only 1 time7\t}8}RunArrays may be initialized with braces, and then size may be omitted:1char message[] = {'H', 'i'}; // but \"Hi\" == {'H', 'i', '\\0'}RunWhen and only when there is less values, the missing elements will be set to zero (for static, extern, and even auto):1int months[12] = {1, 2}; // == {1, 2, 0, 0, ..., 0}RunThere is new form (C99+):1int months[12] = {[0] = 1, [5] = 6}; // and zero at othersRunrecursion spends memory for calls stack, so it's not the most effective way, but often quite compact and easy to read/write/understand.<br>See ex. about <a data-tooltip-position=\"top\" aria-label=\"file:///Users/rayskiy7/dev/new_beginning/c/KR/ch4/recursion.c\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"file:/Users/rayskiy7/dev/new_beginning/c/KR/ch4/recursion.c\" target=\"_self\">recursion</a>.You can multiline your #define:1#define NAME some\\2long textRunYou can use params:1#define SQUARE(X) X*XRunbut there are dangerous pitfalls:\nSQUARE(z+1) ‚Äî&gt; z+1*z+1 ‚Äî violation of operation order (so SQUARE(X) (X)*(X) can help)\nSQUARE(a++) ‚Äî&gt; a++*a++ ‚Äî unwanted double increment side effect\nand so on\nYou can undef a macro:1#undef SQUARERunThere is stringify operator # in #define:1#define debug(expr) printf(#expr \" = %g\\n\", expr)RunIt will replace x+y ‚Äî&gt; \"x+y\".\nFor valid token expr screens \" and \\ with \\\" and \\\\ accordingly.There is operator ## also for concatenate args:1#define glue(x,y) x ## y2glue(a+b,aby); // evaluated to `a+baby`, ##-adjacent spaces are removedRun(carefully: nested uses ## are arcane...)#if expr line may not include sizeof, casts, enum consts.\nIf expr is not zero, lines until other if-macros are included.\nCan use:1#if defined(NAME)RunPattern for only once including section is:1#if !defined(HDR)2#define HDR34/* contents of hdr.h go here */56#endifRunSpecialized forms of #if defined(NAME) can be replaces as:1#ifdef2#ifndefRunUses macros from std library and special convention:1#include &lt;stdarg.h&gt;23void func(int lastnamed, ...)4{5\tva_list ap; // pointer to each unnamed arg6\tva_start(ap, lastnamed); // make ap point to 1st unnamed arg7\t//usage:8\tfloat x = va_arg(ap, float); // get explicit type value9\tva_end(ap); // required finalization10}RunFrom legacy: char* was replaced with *void as a proper type of general pointer!It's possible to take address only for value in memory, so you can't:1int *p = &amp;4; // WRONG!2int *p = &amp;(4-VAL*2); // WRONG!3register int a = 7;4int *p = &amp;a; // WRONG!RunName of * in english is:\nindirection\ndereferencing\nUseful mnemonic\nVariable in declaration mimics the syntax in which the variable might appear\nExample:1double *dp, atof(char *);Run<br>In function you can affect caller args via address. See <a data-tooltip-position=\"top\" aria-label=\"file:///Users/rayskiy7/dev/new_beginning/c/KR/ch5/getfloat.c\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"file:/Users/rayskiy7/dev/new_beginning/c/KR/ch5/getfloat.c\" target=\"_self\">getfloat example</a>.\nPointer version of arrays operations in general is faster (at least to the uninitiated)\nPointer arithmetic works not literally, but address-wise. So int* + 1 increase real value by sizeof(int).Let a ‚Äî array, and pa = &amp;a[0]\nThen value of array is equal to the address of first element:1a == &amp;a[0]RunFurthermore, compiler immediately converts:1a[i] ‚Äî&gt; *(a+i)RunThus, you can use array with arithmetic (for addressing) and pointer with indexing (for dereferencing):1a+i; // a[i]2pa[i]; // a[i]RunBut keep in mind the difference\nAn array name is not a variable, so it's not a modifiable lvalue, and it's wrong:\na = pa; (can't assign to array)\na++; (can't modify value)\nIn fact, these parameters are equal:1void f(char a[]); // indeed is char *a, –Ω–æ –Ω–µ–∏–∑–º–µ–Ω—è–µ–º—ã–π!2void g(char *ap); // used more often, because allow the self-value changesRunOh My God! The incredible insight!\nAll const literal data (except for ordinal small numbers) has its own place at bytecode in .rodata (read only data). Thus, there are something like: 19384717236L\n\"Hello, world!\"\n{1,2,3,4,5,6,7,8,9,10} But remember, you can't do something like:\nchar* str = \"hello\"; str[0] = 'H';\nIt causes bus error or other!\nFor func void print(char* str); each of the next is valid:\nprint(\"Hello, world\"); // string constant\nprint(array); // char array[100]\nprint(ptr); // char *ptr\nWith syntax sugar (that compiler implicit replace f(int []arr); with f(int* arr);) it's possible to call:1f(ap+2);2f(&amp;ap[2]);RunBut you can't:1int array[] = ap; // WRONG!RunBecause array is always memory allocation by compiler, not just refer to some place. See more at two sections ahead.Note\nIf one is sure, it's also possible to index backwards: a[-1], a[-2], and so on.\nPointers and integers are not interchangeable! The sole exception is 0. There is a special const:1#include &lt;stdio.h&gt;2NULL; // == 0, for special meaning of specific pointerRunBut note: NULL is just macro, not a part of the language.\nNote: pointers arithmetic or comparisons work properly for 0, addresses of the same array and address of the first element past the end of this array.\nThere are special types in C:\nptrdiff_t for pointers' difference\nsize_t for sizeof result\nThere is an important difference between definitions:1char amessage[] = \"Hello!\"; // is [H e l l o ! \\0]2char *pmessage = \"Hello!\"; // just [ ] -&gt; .rodata{H e l l o ! \\0}RunWow\nFor string copy until '\\0' is gotten, there is a pretty pattern:\nwhile (*s++ = *t++);\nBecause '\\0' is 0 and 0 is false for boolean-comparison\n<br>See exercise <a data-tooltip-position=\"top\" aria-label=\"file:///Users/rayskiy7/dev/new_beginning/c/KR/ch5/strend.c\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"file:/Users/rayskiy7/dev/new_beginning/c/KR/ch5/strend.c\" target=\"_self\">strend</a>.<br>See line sorting with array of pointers: <a data-tooltip-position=\"top\" aria-label=\"file:///Users/rayskiy7/dev/new_beginning/c/KR/ch5/sortlines.c\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"file:/Users/rayskiy7/dev/new_beginning/c/KR/ch5/sortlines.c\" target=\"_self\">exercise</a>.One important peculiarity, compiler must know step for pointer increment:1void func(int arr[2][6][8]){...}2‚âà3void func(int arr[][6][8]){...} // possible to ommit first dimension4// but only first!56// Same as for extern arrays:7extern int arr[7][5];8extern int arr[][5]; // valid9extern int arr[][]; // WRONG!RunModern way:1void func(int x, int y, int z, int arr[x][y][z]){...}Run\nMulti-dimensional (MD) arrays are stored sequentially, so you can send 3-dimensional array to function, that waits for a 1-dimensional.\nBut: if MD array allocated dynamically, its elements may be not sequential in the memory.There is difference between:1int a[10][20];2int *b[10];RunIn the former ‚Äî memory is allocated actually (200 ints), in the latter ‚Äî just 10 pointers are really stored. Eval a[1] don't loads memory for a, but b[1] loads value of b, see asm:1ldr w8, [sp, #28] ; read a[1]vs.1ldr x8, [sp, #16] ; b &lt;- not hardcoded and need to be gotten from memory2ldr w8, [x8, #4] ; b[1]1// myprogram hello, world2int main(int argc, char *argv[])3{4\t// argc == 35\t// argv[0] ‚Äî&gt; myprogram6\t// argv[1] ‚Äî&gt; hello,7\t// argv[2] ‚Äî&gt; world8\t// argv[3] == 0 (nullptr) ‚Äî that standard requires9}RunFunction, in fact, is address already, so:1&amp;func == func // same as arr==&amp;arrRunIn C, a function is not a variable, but it's possible to define a pointer to function:1void sort(int (*comp)(void*, void*), void *elements[]){2\t...3\t(*comp)(p1, p2); // should be unreferenced for call4\t...5}6int direct_order(char *a, char *b); extern char *elements[];78// send `direct_order` to `sort`9sort((int (*)(void*,void*))direct_order, (void**)elements);Run<br>See huge example <a data-tooltip-position=\"top\" aria-label=\"file:///Users/rayskiy7/dev/new_beginning/c/KR/ch5/sortlines.c\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"file:/Users/rayskiy7/dev/new_beginning/c/KR/ch5/sortlines.c\" target=\"_self\">sortlines</a>.This example has shown the important moment: we can't cast (char *lines[100]) even to (char*[]) because it is cast from complete type to incomplete type.\nIt's possible to cast to incomplete type in some rare cases (from GPT):\ncomplete * ‚Äî&gt; incomplete * (it casts a pointer)\nincomplete ‚Äî&gt; incomplete\nThe reason of complicated declaration is that C syntax is an attempt to make the declarations and the use agree! (I write as i read)Precise C cpecification\nThe precise grammar that specifies a declarator (dcl) uses BNF-grammar\nSimplified form is:1dcl: optional *'s direct-dcl2direct-dcl: name3 (dcl)4 direct-dcl()5 direct-dcl[optional size]For instance:\n(*pfa[])()\nIllustration of the parsing with a parse tree:<br>\n<img alt=\"Screenshot 2025-09-25 at 02.53.33.png\" src=\"a9s/screenshot-2025-09-25-at-02.53.33.png\" target=\"_self\" style=\"width: 400px; max-width: 100%;\">Basic view:1struct point {2\tint x; // structure member3\tint y;4}; // Pay attention to the semicolon!Run\nNote: struct name (which is often called structure tag) is optional\nImportant\nYou must use \";\" at the end of struct declaration.\nIt is statement! (All statements must be ended with \";\")\nStructure name, its member name and also an ordinary variable can have the same name! (since they can always be distinguished by context)Declaration and definition forms:1struct point {2\tint x;3\tint y;4} p1, p2;5struct point p3 = {7, -3}; // with initializationRunImportant\nIn C, type name is struct point, not just point\nFor access a member they use operator \".\":1printf(\"%d\\n\", p2.y);RunStructures can be nested:1struct rect {2\tstruct point pt1;3\tstruct point pt2;4};RunThe only legal operations on a structure:\ncopying\nassigning\ntake address &amp;\naccess members \".\"\nIn C99+ you can:1struct point{int x; int y;} p;2p = (struct point){1, 2};RunStructure parameters are passed by value like any others.Ways to access structure members:1struct rect r, *rp = &amp;r;2r.pt1.x;3rp-&gt;pt1.x;RunYou can initialize in-place:1struct key {2\tchar *word;3\tint count;4} keytab[] = { // empty brackets ([])5\t\"auto\", 0, // no nested braces ({})6\t\"break\", 0,7\t...8}RunImportant: sizeof is a compile-time operator that can be used to compute size of any object in bytes:1sizeof object // variable, array or structure. Not typename2sizeof (typename)3// pay attention to these two different formsRunA good way to define compile-time determinated array is macro, that protects from type changes:1#define ARRLENGTH (sizeof arr / sizeof arr[0]) // or / sizeof (&lt;el type&gt;)RunNote: sizeof can't be used in #if, because the preprocessor does not parse type names.<br>See example <a data-tooltip-position=\"top\" aria-label=\"file:///Users/rayskiy7/dev/new_beginning/c/KR/ch6/countwords.c\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"file:/Users/rayskiy7/dev/new_beginning/c/KR/ch6/countwords.c\" target=\"_self\">countwords</a>. It also applies to later subparagraphs.Don't assume that size of a structure is the sum of the sizes of its members. Alignment may be involved by compiler. Use: sizeof (struct mystructurename).You can use this prettified form for long return types (on your taste):1struct mystructurename *2func(...&lt;params&gt;)Run\nIt's illegal to put a struct in itself declaration, but it's legal to put a pointer to this struct.\n1struct s{2\tstruct s next; // WRONG3\tstruct s *next; // valid4}RunYou can cycle structures, but best practice is to declare latter before:1struct b; // forward declaration, good to use!23struct a { struct b *p; };4struct b { struct a *p; };Run<br>See example <a data-tooltip-position=\"top\" aria-label=\"file:///Users/rayskiy7/dev/new_beginning/c/KR/ch6/hashtable.c\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"file:/Users/rayskiy7/dev/new_beginning/c/KR/ch6/hashtable.c\" target=\"_self\">hashtable</a>.You can define type synonyms:1typedef int *const Ints[10]; // you must set array size. Incomplete types2 // are not allowed34//usage:5Ints ints = {&amp;a, &amp;b}; // first 2 are inited with adressesRunMore complicated example:1typedef struct tnode *Treeptr;23typedef struct tnode { // note: struct tnode type is defined too!4\tchar *word;5\tint count;6\tTreeptr left;7\tTreeptr right;8} Treenode;RunNote\ntypedef just adds a new name for some existing types, thus it is a simple textual substitution, but more efficient than #define\nBesides purely aesthetic issues, there are two main reasons for using typedef:\nportability (e.g. size_t, ptrdiff_t)\nbetter documentation\nImportant\nThere are 2 types of alignment: internal (within a structure), external (among memory addresses).\nUnion variables may hold (at different times) objects of different types and sizes, with the compiler keeping track of size and alignment requirements:1union data{2\tint ival;3\tfloat fval;4\tchar *sval;5} var;RunFacts:\nsyntax based on structures\nvar is large enough to hold the largest of member types\nresponsibility is on programmer: store/retrieve the correct type\nspecific var size and misusing error is machine-dependent\naccess elements just as for structures (. and -&gt;)\nUnion may only be initialized with value of the type of its first member, or in C99+:1union Data {2 int i;3 float f;4}5union Data d = {.f = 3.14f}; // designated initializerRunFor avoid bit-work with masks and bit-wise arithmetic you can use:1// declaration:2struct {3\tunsigned int is_keyword : 1;4\tunsigned int is_extern : 1;5\tunsigned int is_static : 1;6} flags;78// usage:9flags.is_extern = flags.is_static = 1;10if (flags.is_extern == 0 &amp;&amp; flags.is_static == 0)11\t&lt;then ...&gt;;RunBe careful:\nalmost everything about bit-fields is implementation-dependent (whether a bit-field may overlap a word boundary; assignation left-right or right-left). You should not to pick apart externally-defined data. Use unsigned for portability\nbit-fields may be unnamed for manual padding, special width : 0 may be used to force alignment at the next word boundary (machine word)\ncan be declared only as int (and _Bool for new standards)\ncan't be referenced with &amp;\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Kernighan &amp; Ritchie ‚Äî C PL","level":1,"id":"Kernighan_&_Ritchie_‚Äî_C_PL_0"},{"heading":"Introduction","level":1,"id":"Introduction_0"},{"heading":"Chapter 1. A tutorial introduction","level":1,"id":"Chapter_1._A_tutorial_introduction_0"},{"heading":"Chapter 2. Types, Operators, Expressions","level":1,"id":"Chapter_2._Types,_Operators,_Expressions_0"},{"heading":"Chapter 3. Control flow","level":1,"id":"Chapter_3._Control_flow_0"},{"heading":"Chapter 4. Functions and Program Structure","level":1,"id":"Chapter_4._Functions_and_Program_Structure_0"},{"heading":"<strong>Initialization</strong>","level":2,"id":"**Initialization**_0"},{"heading":"Recursion","level":2,"id":"Recursion_0"},{"heading":"The C Preprocessor","level":2,"id":"The_C_Preprocessor_0"},{"heading":"Macro substitution","level":3,"id":"Macro_substitution_0"},{"heading":"Conditional inclusion","level":3,"id":"Conditional_inclusion_0"},{"heading":"Variable-length Argument Lists","level":2,"id":"Variable-length_Argument_Lists_0"},{"heading":"Chapter 5. Pointers and Arrays","level":1,"id":"Chapter_5._Pointers_and_Arrays_0"},{"heading":"Pointers and Addresses","level":2,"id":"Pointers_and_Addresses_0"},{"heading":"Pointers and Function Arguments","level":2,"id":"Pointers_and_Function_Arguments_0"},{"heading":"Pointers and Arrays","level":2,"id":"Pointers_and_Arrays_0"},{"heading":"Address Arithmetic","level":2,"id":"Address_Arithmetic_0"},{"heading":"Character Pointers and Functions","level":2,"id":"Character_Pointers_and_Functions_0"},{"heading":"Pointer Arrays; Pointers to Pointers","level":2,"id":"Pointer_Arrays;_Pointers_to_Pointers_0"},{"heading":"Multi-dimensional Arrays","level":2,"id":"Multi-dimensional_Arrays_0"},{"heading":"Pointers vs. Multi-dimensional Arrays","level":2,"id":"Pointers_vs._Multi-dimensional_Arrays_0"},{"heading":"Command-line Arguments","level":2,"id":"Command-line_Arguments_0"},{"heading":"Pointers to Functions","level":2,"id":"Pointers_to_Functions_0"},{"heading":"Complicated Declarations","level":2,"id":"Complicated_Declarations_0"},{"heading":"Chapter 6. Structures","level":1,"id":"Chapter_6._Structures_0"},{"heading":"Basic of Structures","level":2,"id":"Basic_of_Structures_0"},{"heading":"Structures and Functions","level":2,"id":"Structures_and_Functions_0"},{"heading":"Arrays of Structures","level":2,"id":"Arrays_of_Structures_0"},{"heading":"Pointers to Structures","level":2,"id":"Pointers_to_Structures_0"},{"heading":"Self-referential Structures","level":2,"id":"Self-referential_Structures_0"},{"heading":"Table lookup","level":2,"id":"Table_lookup_0"},{"heading":"Typedef","level":2,"id":"Typedef_0"},{"heading":"Unions","level":2,"id":"Unions_0"},{"heading":"Bit-fields","level":2,"id":"Bit-fields_0"}],"links":["file:///Users/rayskiy7/dev/new_beginning/c/KR/longest_line.c","file:///Users/rayskiy7/dev/new_beginning/c/KR/htoi.c","file:///Users/rayskiy7/dev/new_beginning/c/KR/squeeze.c","file:///Users/rayskiy7/dev/new_beginning/c/KR/escapes.c","file:///Users/rayskiy7/dev/new_beginning/c/KR/ch4/stack.c","file:///Users/rayskiy7/dev/new_beginning/c/KR/ch4/recursion.c","file:///Users/rayskiy7/dev/new_beginning/c/KR/ch5/getfloat.c","file:///Users/rayskiy7/dev/new_beginning/c/KR/ch5/strend.c","file:///Users/rayskiy7/dev/new_beginning/c/KR/ch5/sortlines.c","file:///Users/rayskiy7/dev/new_beginning/c/KR/ch5/sortlines.c","file:///Users/rayskiy7/dev/new_beginning/c/KR/ch6/countwords.c","file:///Users/rayskiy7/dev/new_beginning/c/KR/ch6/hashtable.c"],"author":"","coverImageURL":".","fullURL":"kernighan-&-ritchie-‚Äî-c-pl.html","pathToRoot":".","attachments":["a9s/screenshot-2025-09-27-at-22.49.48.png","a9s/screenshot-2025-09-20-at-01.48.06.png","a9s/screenshot-2025-09-20-at-13.23.06.png","a9s/screenshot-2025-09-20-at-15.44.51.png","a9s/screenshot-2025-09-25-at-02.53.33.png"],"createdTime":1758074369052,"modifiedTime":1766965293263,"sourceSize":25323,"sourcePath":"engineering/compendium/Kernighan & Ritchie ‚Äî C PL.md","exportPath":"kernighan-&-ritchie-‚Äî-c-pl.html","showInTree":true,"treeOrder":3,"backlinks":[],"type":"markdown"},"start-page.html":{"title":"Start page","icon":"","description":"This is selected collection of my book notes!\nüëàüèº All works can be found in the left side-bar","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"","fullURL":"start-page.html","pathToRoot":".","attachments":[],"createdTime":1767014780778,"modifiedTime":1767016904330,"sourceSize":99,"sourcePath":"engineering/compendium/Start page.md","exportPath":"start-page.html","showInTree":true,"treeOrder":4,"backlinks":[],"type":"markdown"},"stroustrup-b./tc++pl.-tome-1.html":{"title":"TC++PL. Tome 1","icon":"","description":"C++ is based on the idea of providing both:\ndirect mappings of build-in operations and types ti hardware to provide efficient memory use and efficient low-level operations, and\naffordable and flexible abstractions mechanisms to provide user-defined types with the same notation support, range of uses&lt; and performance as build-in types. C++ is a language for developing and using elegant and efficient abstractions. C++ concentrates on system programming. C++ follows zero-overhead principle.\nNote\nDon't assume that something laboriously written in C style is more efficient than a shorter alternative. Often, the opposite is true.\nAims for the C++11 effort were:\nMake C++ a better language for systems programming and library building\nMake C++ easier to teach and learn\nAlso to introduce concurrent systems programming type-safe and portable (new memory model, facilities for lock-free programming)\nMost widely useful features of C++11:\n=delete, =default\nauto (type deducing)\nconstexpr\nmove semantic\nnoexcept\nrange-for statement\nfinal and override\nenum class\nAbout new features of standard library:\nunordered_map and so on\nthread, mutex, lock\nfuture, promise, async()\ngarbage collector interface\nregexp\nrandom numbers\nunique_ptr (originally called move_ptr, auto_ptr)\nshared_ptr (originally counted_ptr)\ntuple\nbind()\nfunction type\nC++ is considerable to have unique strengths in the area of infrastructure software.\nrepresent ideas directly in code\naim: elegant and efficient\ndon't overabstract\ntry elegant and efficient abstractions from libraries\nrepresent relations directly in code\nrepresent independent ideas separately in code\nC++ is not just object-oriented\nC++ is not just for generic programming\nprefer solutions that can be statically checked (compile-time preference)\nmake resources explicit (as class objects)\nexpress simple ideas simply\nuse libraries. don't build everything from scratch\nuse type-rich style of programming\ndon't avoid high-level abstractions out of fear of performance problems\nif data has an invariant ‚Äî encapsulate it\nC++ is not just C with a few extensions\nThe ISO C++ standard defines two kinds of entities:\nCore language features (build-in types, loops, etc.)\nStandard-library components (containers, I/O operations)\nsee: <a data-tooltip-position=\"top\" aria-label=\"file:///Users/rayskiy7/dev/new_beginning/cpp/Stroustrup_cpp/ch2/helloworld.cpp\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"file:/Users/rayskiy7/dev/new_beginning/cpp/Stroustrup_cpp/ch2/helloworld.cpp\" target=\"_self\">hello world</a>.C++ introduces bool type.Different ways to initialize:1int i = 2.3; // truncates to 22int i {2.3}; // error3int i = {2.3}; // error\nDon't introduce a name until you have a suitable value for it! Even using user-defined types\ntype can be deduced from the initializer:1auto b = true;2auto ch = 'x';3auto i = 123;4auto d = 1.2;5auto z = sqrt(y); // gets type from sqrt resultContrary\nWith auto we use =, not {} syntax for init\nSpecific reasons to use explicit type declaration:\nfor readability (in large scopes)\nbe explicit about range or precision (e.g., double rather than float)\nThere are two notions of immutability:\nconst ‚Äî \"I promise not to change this value\"\nconstexpr ‚Äî \"To be evaluated at compile time\"\nIt's possible to define constexpr functions:1constexpr double square(double x){ return x*x; }It calls will be evaluated on compile timeWarning\nTo be a constexpr function must include only return statement. (But see also consteval in C++20)\nconstexpr functions may be called with no-constexpr args.In few places it must be constexpr:\narray bounds\ncase labels\nsome template arguments\nconstants declared using constexpr\nNew range-for-statement:1int v[] = {0,1,2,3,4,5,5,6,7,8,9};23for (auto x : v)4\tcout &lt;&lt; x &lt;&lt; '\\n';56for (auto x : {10, 20, 30}) // even for in-place defined arrays7\tcout &lt;&lt; x &lt;&lt; '\\n';It's also possible to have the objects themself, not copy:1int v[] = {0,1,2,3,4,5,5,6,7,8,9};23for (auto&amp; x : v)4\t++x;About &amp;\nA reference cannot be made to refer to a different object after its initialization\nC++ introduces nullprt:1double* dp = nullptr;2Link&lt;Record&gt;* lst = nullptr;In declaration operators &amp;, *, [], () (invokation) are called declarator operators.\nBuilt-in types ‚Äî fundamental types and their derivatives built from them, const and declarator operators.Unlike in C, in C++ struct types can be referred just by name:1struct Vector {2\tint sz;3\tdouble* elem;4};56Vector v; // not `struct Vector v;`A way to dynamically allocate memory and init Vector:1void vector_init(Vector&amp; v, int s)2{3\tv.elem = new double[s];4\tv.sz = s;5}Runnew allocates from the free storage | dynamic memory | heap.Example:1class Vector {2public:3\tVector(int s) : elem{new double[s]}, sz{s} {}4\tdouble&amp; operator[](int i) {return elem[i];} // no `&amp;`?5\tint size() {return sz;}6private:7\tdouble* elem;8\tint sz;9};1011//usage:12Vector v(6);RunC++ introduces enum class that is not just enum (plain enum) from C, but is its extended version:1enum class Color {red, blue, green};2enum class Light {green, yellow, red};34// usage:5Color c = Color::red;6Light l = Light::red;RunAn enumeration is a user-defined type so we can define operators for it:1Light&amp; operator++(Light&amp; l) // prefix form(!)2{3\tswitch(l){4\tcase Light::green: return l = Light::yellow;5\tcase Light::yellow: return l = Light::red;6\tcase Light::red: return l = Light::green;7\t}8}910//usage:11Light l = Light::yellow;12Light next = ++l;RunDS says: a program consists of entities: variables, functions, types. Declaration ‚Äî all that compiler needs.Example without any definitions. There are only declaration (interface):1double sqrt(double);23class Vector {4public:5\tVector (int s);6\tdouble&amp; operator[](int i);7\tint size();8private:9\tint sz;10\tdouble* elem;11};RunDS says: inside a namespace you can put everything you can put into global space.For not to conflict with global names from std you can use namespaces. Example:1namespace My_code {2\tclass complex{3 ...4\t};5\tcomplex sqrt(complex);6\tint main();7}89int My_code::main()10{11\tcomplex z1 {1, 2}; // not My_code::complex, just complex12\tauto z2 = sqrt(z1);13}1415int main()16{17\treturn My_code::main();18}Runusing-directive:1using namespace std;RunYou can just throw in critical section:1double&amp; Vector::operator[](int i)2{3\tif (i&lt;0 || i &gt;= size())4 throw out_of_range{\"Vector::operator[]\"};5\treturn elem[i];6}78// usage, later:9try {10\tv[v.size()] = 7; // throws exception11}12catch (out_of_range) {13\t... // handle exception14}RunSome stable state of correct class object must be observed. It's work for a constructor to set invariant, and public methods must to maintain the invariant (at least on the return). And then destructor can rely on that invariant.On the compile time:1// first arg must be constexpr2static_assert(sizeof(int)&gt;=4, \"integers are too small\"); // check type sizeRunOften used in generic programming for make assertions about concrete types.\nYou don't have to know every detail of C++ to write good programs\nFocus on programming techniques, not on language features\nClasses in C++ divided on:\nabstract classes\nconcrete classes\nThere is an ordinary example. Pay attention to const method of class, such one can not to change object at all:1class complex {2\tdouble re, im;3public:4\tcomplex(double r, double i) : re{r}, im{i} {}5\tcomplex(double r) : re{r}, im{0} {}6\tcomplex() : re{0}, im{0} {}78\tvoid real(double d) {re=d;}9\tvoid imag(double d) {im=d;}10\tdouble real() const {return re;}11\tdouble imag() const {return im;}1213\tcomplex&amp; operator+=(complex z) {re+=z.re, im+=z.im; return *this;}14\tcomplex&amp; operator-=(complex z) {re-=z.re, im-=z.im; return *this;}15\tcomplex&amp; operator*=(complex); // just declaration16\tcomplex&amp; operator/=(complex); // just declaration17};RunWow\nFunction defined (not declared) in a class are inlined by default!\n<br>see about inline: <a data-href=\"üîó –°++ all modifiers#^inlinevar\" href=\"engineering/c++-essentials/üîó-—Å++-all-modifiers.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">üîó –°++ all modifiers &gt; ^inlinevar</a>\nBy defining a default constructor you eliminate the possibility of uninitialized variables of that type (complex).\nOperations that don't require direct access to the representation can be defined separately (out of class):1complex operator+(complex a, complex b) {return a+=b;}2complex operator-(complex a, complex b) {return a-=b;}3complex operator-(complex a) {return {-a.real(), -a.imag()};} // unary minus4bool operator==(complex a, complex b) {5\treturn a.real()==b.real() &amp;&amp; a.imag()==b.imag();6}RunNote: a+=b doesn't change the original because param a is considered as a copy.1//usage:2complex a {2.3};3complex b {1/a}; // copy?4complex c {a + z*complex{1, 2.3}};5if (c!=b) {...}Run<br>see <a data-tooltip-position=\"top\" aria-label=\"file:///Users/rayskiy7/dev/new_beginning/cpp/Stroustrup_cpp/ch3/mycomplex.cpp\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"file:/Users/rayskiy7/dev/new_beginning/cpp/Stroustrup_cpp/ch3/mycomplex.cpp\" target=\"_self\">example</a>.Destructor example:1class Vector{2private:3\tdouble* elem;4\tint sz;5public:6\tVector(int s) : elem{new double[s]}, sz{s} {7 for (int i=0; i!=s; ++i) elem[i]=0;8\t}9\t~Vector() {delete[] elem;}10\tdouble&amp; operator[](int i);11\tint size() const;12};Rundef\nRAII (Resource Acquisition Is Initialization) ‚Äî the technique of acquiring resources in a constructor and releasing them in a destructor\nFor use {1, 2, 3} form you need use std::initializer_list&lt;T&gt;. Example:1class Vector{2public:3\tVector(std::initializer_list&lt;double&gt;);4\tvoid push_back(double);5};RunAlso you can use stream:1Vector read(istream&amp; is)2{3\tVector v;4\tfor (double d; is&gt;&gt;d; )5 v.push_back(d);6\treturn v;7}RunDS says:<br>\n<img alt=\"Screenshot 2025-09-29 at 04.15.37.png\" src=\"a9s/screenshot-2025-09-29-at-04.15.37.png\" target=\"_self\" style=\"width: 300px; max-width: 100%;\">\nFor abstract classes we must allocate objects on the heap and access them through references or pointers, because we do not even know the size of an object.\nAbstract class example:1class Container { // this class is a pure interface2public:3\tvirtual double&amp; operator[](int) = 0; // pure virtual func4\tvirtual int size() const = 0;5\tvirtual ~Container() {}6};Rundef\nvirual means \"may be redefined lated in a class derived from this one\".\ndef\npure virtual function =0 means that some class derived from Container must define the function.\ndef\nAbstract class is a class with a pure virtual function.\ndef\nPolymorphic type is a class with a virtual function.\nImportant\nPolymorphic types have a virtual destructor because they (their instances) tend to be manipulated through references/pointers, and someone destroying an instance (with ref type) has no idea what resources must be released.\nRealization example:1class VectorC : public Container {2\tVector v;3public:4\tVectorC(int s): v(s) {}5\t~VectorC() {} // override6\tdouble&amp; operator[](int i){return v[i];} // override7\tint size() const {return v.size();} // override8};RunNote\nMember (v) destructor ~Vector() is implicitly invoked by its class's destructor (~VectorC())\nUsage:1void use(Container&amp; c)2{3\tconst int sz = c.size();4\tfor (int i=0; i!=sz; ++i)5 cout &lt;&lt; c[i] &lt;&lt; '\\n';6}78void func()9{10\tVectorC vc {0,1,2,3,4,5};11\tuse(vc); // as Container&amp;, not VectorC&amp;12}RunThe usual implementation technique for selecting the right realization of the virtual function is converting of virtual function names into indices into a table of pointers to functions. This table is called the virtual function table or just vtbl. Each class with virtual functions has its own vtbl identifying its virtual functions.\nGraphically:<br>\n<img alt=\"Screenshot 2025-09-29 at 15.56.15.png\" src=\"a9s/screenshot-2025-09-29-at-15.56.15.png\" target=\"_self\" style=\"width: 600px; max-width: 100%;\">This mechanism is almost as efficient as the normal function call, but is slower within 25%.\nAbout memory: +1[] for each class and +1* for each instance.Helpful to know!\nGPT says: in general, all functions from base-class and in derived-class, even if they have the same signatures (override), are different in the machine code\nFor hierarchy Shape -&gt; Circle -&gt; Smiley you can access super-classes:1void Smiley::draw()2{3\tCircle::draw();4\tfor (auto p: eyes)5 p-&gt;draw(); // Shape::draw6\tmounth-&gt;draw(); // Shape::draw7}Run\nNote: virtual destructor is necessary, because delete is often used with pointer to a base class.\nNote: concrete destructor (called by vtbl) implicitly invokes the destructors of base classes and members.\nA class hierarchy offers two kinds of benefits:\nInterface inheritance\nImplementation inheritance\nIf user of Shapes forget to delete them, it cause memory leak. For this case there is:1{2\tauto s = unique_ptr&lt;Shape&gt;{new Circle{p, r}};3} // s is deleted hereRun1void test(complex z1)2{3\tcomplex z2{z1}; // copy initialization4\tcomplex z3;5\tz3 = z2; // copy assignment6}RunFor simple types memberwise copy is often used. But for some Containers it is not the right semantic, and for abstract types it almost never is.Strong hint\nThe fact that Vector has a destructor hints that the default (memberwise) copy semantic is wrong\nCopying of objects is defined by:1class Vector {2private:3\tdouble* elem; // 1st to init4\tint sz; // 2nd to init5public:6\tVector(int s);7\t~Vector() {delete[] elem;}8\tVector(const Vector&amp; a); // copy constructor9\tVector&amp; operator=(const Vector&amp; a); // copy assignment1011\tdouble&amp; operator[](int i); // for commmon objects12\tconst double&amp; operator[](int i) const; // for const objects1314\tint size() const;15};RunRealization examples:1Vector::Vector(const Vector&amp; a)2\t:elem{new double[a.sz]},3\tsz{a.sz}4{5\tfor (int i=0; i!=sz; ++i)6 elem[i] = a.elem[i];7}89Vector&amp; Vector::operator=(const Vector&amp; a)10{11\tdoubple* p new double[a.sz];12\tfor (int i=0; i!=a.sz; ++i)13 p[i] = a.elem[i];14\tdelete[] elem; // IMPORTANT15\telem = p;16\tsz = a.sz;17\treturn *this; // predefined Class* this;18}RunOn return from function Vector ...(...)...{...return v;} object Vector is copied, and for large data it is pointless. To state intent we want to move it rather than copy there is:1class Vector {2\t// ...3\tVector(const Vector&amp; a); // copy constructor4\tVector&amp; operator=(const Vector&amp; a); // copy assignment5\t6\tVector(Vector&amp;&amp; a); // move constructor7\tVector&amp; operator=(Vector&amp;&amp; a); // move assignment8};910Vecto::Vector(Vector&amp;&amp; a)11\t:elem{a.elem}, // \"grab the element\" from a12\tsz{a.sz}, // \"grab the element\" from a13{14\ta.elem = nullptr; // now `a` has no elements15\ta.sz = 0;16}RunFor that definition compiler will chose the move constructor to implement the transfer of the return value out of the function.For clarifying various types, GPT+DS says:1* ‚Äî pointer2&amp; ‚Äî lvalue-reference3&amp;&amp; ‚Äî rvalue-reference45// special rule:6const T&amp; ‚Äî can be attached to rvalue78NRVO (Named Return Value Optimization)RunImportant\nAfter a move, a moved-from object (grabbed) should be in state that allows a destructor to be run.\nTypically, we should also allow assignment to a moved-from (grabbed) object.\nIf value will not be used again (that is not obvious for the compiler), you can:1Vector f()2{3\tVector a(100);4\tVector y(100);5\tVector z(100);6\tz = x; // move7\ty = std::move(x); // move (specified), returns an Vector&amp;&amp;8\treturn z; // move9}RunOn return x is empty from line 7, z is empty from line 8, and then x,y,z are destroed.Vector, std::thread ‚Äî resource handles, and move semantic makes its an alternative to using pointers in many cases.In fact, unique_ptr and others are themselves resource handles.Replacing new/delete with move semantic may achieve strong resource safety; that is we can eliminate resource leaks for a general notion of resource (e.g., vectors for data, threads for sys threads, and fstreams for file handles)One (but not the only) example when we don't wanna copy object: base class in class hierarchy. Then the best thing to do is usually to delete the default copy/move constructors:1class Shape{2public:3\tShape(const Shape&amp;) = delete; // no copy constr4\tShape&amp; operator=(const Shape&amp;) = delete; // no copy assign56\tShape(Shape&amp;&amp;) = delete; // no move constr7\tShape&amp; operator=(Shape&amp;&amp;) = delete; // no move assign89\t~Shape(); // &lt;- (read note below)10}RunNote\nIf user has explicitly declared destructor, the compile will not implicitly generate move operations. Furthermore:\nmove ‚Äî not generated!\ncopy ‚Äî generated, but deprecated! (will warn)\ndef\ntemplate is a class or function that we parametrize with a set of types or values\nExample:1template&lt;typename T&gt;2class Vector {3private:4\tT* elem;5\tint sz;6public:7\tVector(int s);8\t~Vector() {delete[] elem;}9\t// copy/move operations10\tT&amp; operator[](int i);11\tconst T&amp; operator[](int i) const;12\tint size() const {return sz;}13};RunDefining member functions:1template&lt;typename T&gt;2Vector&lt;T&gt;::Vector(int s)3{4\tif (s&lt;0) throw Negative_size{};5\telem = new T[s];6\tsz = s;7}89template&lt;typename T&gt;10const T&amp; Vector&lt;T&gt;::operator[](int i) const11{12\tif (i&lt;0 || size()&lt;=i)13 throw out_of_range{\"Vector::operator[]\"};14\treturn elem[i];15}RunAnd now we can use generic objects:1Vector&lt;char&gt; vc(200); // 200 chars2Vector&lt;string&gt; vs(17); // 17 strings3Vector&lt;list&lt;int&gt;&gt; vli(45); // 45 lists of intsRun(About C++98 you couldn't use &gt;&gt;, then they used additional blank: &lt; list&lt;int&gt; &gt;)For support for-range loop you must define begin() and end():1template&lt;typename T&gt;2T* begin(Vector&lt;T&gt;&amp; x)3{4\treturn x.size()? &amp;x[0]: nullptr;5}6template&lt;typename T&gt;7T* end(Vector&lt;T&gt;&amp; x)8{9\treturn begin(x) + x.size();10}RunThen use:1void write(const Vector&lt;string&gt;&amp; vs) // strings vector2{3\tfor (auto&amp; s: vs) // for-range4 cout &lt;&lt; s &lt;&lt; '\\n';5}RunFunction compile-time type parametrization:1templace&lt;typename Container, typename Value&gt;2Value sum(const Container&amp; c, Value v)3{4\tfor (auto x : c)5 v+=x;6\treturn v;7}RunUsage:1void use(Vector&lt;int&gt;&amp; vi, std::vector&lt;complex&lt;double&gt;&gt;&amp; vc)2{3\tdouble s = sum(vi, 0.0); // add to double4\t// note: not sum&lt;Vector&lt;int&gt;, double&gt;(...), just sum(...)5\tauto z = sum(vc, complex&lt;double&gt;{});6}Runnote again: type arguments for sum are deduced from call arguments.def\nfunction object as known as functor is object that can be called like functions.\nExample:1template &lt;typename T&gt;2class Complt {3\tconst T val;4public:5\tCompwith(const T&amp; v) : val(v) {}6\tbool operation()(const T&amp; x) const {return x&lt;val;}7};89// use as predicate:1011template&lt;typename C, typename P&gt;12int count(const C&amp; c, P predicate){13\tint cnt=0;14\tfor (const auto&amp; x: c)15 if (predicate(x))16 ++cnt;17\treturn cnt;18}1920void use(){21\tint x = 42;22\tstring s = \"Backus\";23\tComplt&lt;int&gt; lti{x}; // def: policy object24\tComplt&lt;string&gt; lts{s}; // too2526\tconst Vector&lt;int&gt;&amp; vi = ...;27\tconst list&lt;string&gt;&amp; ls = ...;2829\tcout &lt;&lt; count(vi, lti) &lt;&lt; '\\n';30\tcout &lt;&lt; count(ls, lts) &lt;&lt; '\\n';3132\t// or in-place with lambdas:33\tcout &lt;&lt; count(vi, [&amp;](int a){return a&lt;x;}) &lt;&lt; '\\n';34\tcout &lt;&lt; count(ls, [&amp;](const string&amp; a){return a&lt;s;}) &lt;&lt; '\\n';35}Run\n[&amp;] in lambda expression is called a capture list, that specifies that local names used (as x) will be passed by reference.\nPossible types of capture:\n[&amp;x] ‚Äî concrete by reference\n[=x] ‚Äî concrete by copy\n[] ‚Äî capture nothing\n[&amp;] ‚Äî all local names by reference\n[=] ‚Äî all local names by value\nWe can separate the traversal of our container from the specification of what is to be done with each element:1// class ‚âà typename2template&lt;class C, class Oper&gt; // assume C is a Container of pointers3void for_all(C&amp; c, Oper op)4{5\tfor (auto&amp; x: c)6 op(*x); // x is T* and is taken by reference(&amp;), so *x is just x7}89void use()10{11\tvector&lt;unique_ptr&lt;Shape&gt;&gt; v; // may be vector&lt;Shape*&gt;12\twhile (cin)13 v.push_back(read_shape(cin));14\tfor_all(v, [](Shpae&amp; s){s.draw();} ); // x is got by reference(&amp;)15\tfor_all(v, [](Shape&amp; p){s.rotate(45);} );16}RunAs known as variadics.\nExample:1void func() {} // do nothing23template &lt;typename T, typename... Tail&gt;4void func(T head, Tail... tail) // `func` name again!5{6\tg(head); // do something, in fact, on each argument7\tfunc(tail...); // try again with tail, at some time here is f()8}RunGPT says: SFINAE ‚Äî Substitution Failure Is Not An Error.Examples:1using size_t = insigned int;23// Every std contained defines such this:4template&lt;typename T&gt;5class Vector{6public:7\tusing value_type = T;8...9};1011// type of element:12template&lt;typename C&gt;13using eltype = typename C::value_type;14// and then:15templace&lt;typename Cont&gt;16void func(Cont&amp; c)17{18\tVector&lt;eltype&lt;Cont&gt;&gt; vec;19\t// or explicit: Vector&lt;typename Cont::value_type&gt; vec;20}2122// predefined types:23template&lt;typename V&gt;24using stringmap = Map&lt;string, V&gt;;25//and then:26stringmap&lt;int&gt; m; // m has type: Map&lt;string, int&gt;Run\nexpress ideas directly in code\ndefine classes to represent concepts\nuse concrete classes to represent simple concepts and performance-critical components\navoid naked new/delete\nuse resource handles and RAII to manage resources\nuse abstract classes to fully separate interface from implementation\nuse class hierarchies to represent hierarchical concepts\nusing hierarchy you should distinguish between implementation inheritance and interface inheritance (impl-inher / interf-inher)\ncontrol constr/copy/move/destr of your class\nreturn containers by value (relying on move for efficiency)\nprovide strong resource safety (never leak resources)\nuse container for resource handles\nuse templates for general algo/data\nuse functors/lambdas to represent policies/actions\nuse type aliases and template aliases\nThe facilities provided by the standard library can be classified like this:\nrun-time language support (allocation, run-time type info)\nthe C standard library\nstrings, i/o streams (are extensible framework), localization\ncontainers framework, types/algorithms ‚Äî called STL, is extensible\nnumerical computations (math funcs, complex, vectors with arithmetic, random)\nregex\nconcurrency (thread, lock). It is foundational (so you can add support for new models)\nutilities to support templates, STL-style generic programming, generals (clock and others)\n\"smart pointers\", interface for GC\nSpecial-purpose containers (array, bitset, tuple)\nAll of them included because:\nhelpful to almost every C++ programmer\nprovided in a general form and have not significant overhead\nsimple to use, easy to learn (but solves complex tasks)\nThe standard library is defined in a namespace called std for all headers (#include string, list, complex and others...)\nStandardized C++98 introduce new headers without .h extension, so: string.h ‚Äî old C code, string ‚Äî new modern code of C++\nSelection of std headers:<br>\n<img alt=\"Screenshot 2025-10-01 at 02.55.34.png\" src=\"a9s/screenshot-2025-10-01-at-02.55.34.png\" target=\"_self\" style=\"width: 400px; max-width: 100%;\"><br>\n<img alt=\"Screenshot 2025-10-01 at 02.56.03.png\" src=\"a9s/screenshot-2025-10-01-at-02.56.03.png\" target=\"_self\" style=\"width: 600px; max-width: 100%;\">Standard strings are mutable (s+=\"tail\") and have move constructor (so it is efficient to return strings by value).\nSome useful methods:\n.substr(...) returns new string\n.replace(...) modify string&amp;\noperator==(...)\nThe output can be extended for user-defined types (easier than input)There are two out streams: cout and cerr.\nA whitespace character by default terminates the read.\nFor reading whole line use:1string std;2getline(cin, str); // cin == \"Hello world\";RunImportant\ngetline(...) reads and terminating \\n char, but not include it in the result.\nGPT: It should be said: struct and class are almost equivalent. Differences:\nby default struct fields are public, class fields ‚Äî private. The same is with default inheritance\nstruct without private members, constructors and destructors allow aggregate initialization: Point p{10, 20};\nuse struct for simple data, and class for objects with encapsulation and logic\nDefine io for custom types:1struct Entry{2\tstring name;3\tint number;4};56ostream&amp; operator&lt;&lt;(ostream&amp; os, const Entry&amp; e)7{8\treturn os &lt;&lt; \"{\\\"\" &lt;&lt; e.name &lt;&lt; \"\\\", \" &lt;&lt; e.number &lt;&lt; \"}\";9}1011istream&amp; operator&gt;&gt;(istream&amp; is, Entry&amp; e)12{13\tchar c, c2;14\tif (is&gt;&gt;c &amp;&amp; c=='{' &amp;&amp; is&gt;&gt;c2 &amp;&amp; c2=='\"') {15 string name;16 while (is.get(c) &amp;&amp; c!='\"') // analogue of C getchar(char *)17 name += c;18 19 if (is&gt;&gt;c &amp;&amp; c==','){20 int number = 0;21 if (is &gt;&gt; number &gt;&gt; c &amp;&amp; c=='}'){22 e = {name, number};23 return is;24 }25 }26\t}27\tis.setstate(ios_base::failbit);28\treturn is;29}3031// now available:32for (Entry e; cin&gt;&gt;e; )33\tcount &lt;&lt; e &lt;&lt; '\\n';RunRemember\nis &gt;&gt; c skips whitespace by default\nif (is &gt;&gt; c) test whether input was successfully read.Vector example:1vector&lt;Entry&gt; book = {2\t{\"Jane\", 625},3\t{\"Dima Prima\", 93041}, // trailing comma is allowed in many cases4};56// add entries:7for (Entry e; cin&gt;&gt;e; )8\tbook.push_back(e);910vector&lt;Entry&gt; book2(50); // 50 entries {\"\", 0}11vector&lt;Entry&gt; book3(30, {\"x\", 123}); // 30 entries {\"x\", 123}1213for (const auto&amp; e: book)14\tcout &lt;&lt; e &lt;&lt; '\\n';RunOn insert an element std vector copies that value.Std vector does not check the range. For example:1int n = book[book.size()].number; // index is out of rangeRunWarn\nThis code may not produce error, but fills the n with garbage. This is critical.\nThere is a way to eliminate out-of-range problem with vector::at. Adaptor:1template &lt;typename T&gt;2class Vec: public std::vector&lt;T&gt; {3public:4\tusing vector&lt;T&gt;::vector; // use constructors from base5\tT&amp; operator[](int i){return vector&lt;T&gt;::at(i);}6\tconst T&amp; operator[](int i) const {return vector&lt;T&gt;::at(i);}7};RunSome implementations save you the bother of defining adaptors (e.g., as a compiler option).A way to minimize surprises from uncaught exceptions:1int func()2try { // NO BODY. Immediate try-block3\tbook[book.size()] = {\"Joe\", 999999};4}5catch (out_of_range) {6\tcerr &lt;&lt; \"range error\\n\";7}8catch (...) {9\tcerr &lt;&lt; \"unknown exception thrown\\n\";10}RunList is double-linked.Every std container provides:\nbegin() ‚Äî returns iterator to the first element\nend() ‚Äî returns iterator to the one-past-the-last element\nIn fact\nCompiler realizes for-range with begin and end Traverse the list:1int get_number(const string&amp; s)2{3\tfor (auto p = book.begin(); p!=book.end(); ++p)4 if (p-&gt;name==s)5 return p-&gt;number;6\treturn -1; // as error7}RunInsertion and erasion are performed by iterator:1e = ... // some Entry obj2list&lt;Entry&gt;::iterator p = ...3list&lt;Entry&gt;::iterator q = ...45book.insert(p, e);6book.erase(q);RunInfo\nin C++: map is a red-black tree with asymptotic unordered_map is a hash-table with asymptotic Indexing [] of a map returns associated value or zero-value of a type. To avoid this behavior on missing elements you should use find() and insert().An example:1map&lt;string, int&gt; book{ // or unordered_map2\t{\"Dima\", 635},3\t{\"Sasha\", 900},4};RunStd lib provide default hash function for string. You can (and should) provide your own.<br><img alt=\"Screenshot 2025-10-02 at 01.51.27.png\" src=\"a9s/screenshot-2025-10-02-at-01.51.27.png\" target=\"_self\" style=\"width: 600px; max-width: 100%;\">Std lib provides adaptors: queue&lt;T&gt;, stack&lt;T&gt;, deque&lt;T&gt;, priority_queue&lt;T&gt;, and more specialized container-like types: array&lt;T, N&gt;, bitset&lt;N&gt;.Std containers have notational and semantical uniformity.Example for sort and unique:1bool operator&lt;(const Entry&amp; x, const Entry&amp; y)2{3\treturn x.name &lt; y.name;4}5void sort_and_unique(vector&lt;Entry&gt;&amp; vec, list&lt;Entry&gt;&amp; lst)6{7\tsort(vec.begin(), vec.end());8\tunique_copy(vec.begin(), vec.end(), lst.begin());9}RunCaution\nAt this example you should know: unique_copy remove only adjacent equal elements, and lst must have enough space for insertion.\nInserting in newly created collection can be realized with back_inserter:1list&lt;Entry&gt; getunique(vector&lt;Entry&gt;&amp; vec)2{3\tlist&lt;Entry&gt; res;4\tsort(vec.begin(), vec.end());5\tunique_copy(vec.begin(), vec.end(), back_inserter(res));6\treturn res;7}Runfind examples:1bool has_c(const string&amp; s, char c)2{3\tauto p = find(s.begin(), s.end(), c);4\tif (p!=s.end())5 return true;6\telse7 return false;8}910// or11bool has_c(const string&amp; s, char c)12{13\treturn find(s.begin(), s.end(), c) != s.end();14}RunExample (UP: generalized) for find_all with STL:1template&lt;typename C, typename V&gt;2vector&lt;typename C::iterator&gt; find_all(C&amp; c, V c)3{4\tvector&lt;typename C::iterator&gt; res;5\tfor (auto p = s.begin(); p!=s.end(); ++p)6 if (*p==c)7 res.push_bak(p);8\treturn res;9}RunWarn\ntypename for reference to typename C::iterator is necessary. It informs the compiler that C's iterator is supposed to be a type and not a value of some type, say, the integer 7.\nWe can hide this necessity by using type alias:1template &lt;typename T&gt;2using Iterator&lt;T&gt; = typename T::iterator;34template &lt;typename C, typename V&gt;5vector&lt;Iterator&lt;C&gt;&gt; find_all(C&amp; c, V v)6{7\tvector &lt;Iterator&lt;C&gt;&gt; res;8\t‚Äî || ‚Äî ...9}RunWhen matches are found by find_all you can use insert(it, x) or erase(it) or do it manually:1vector&lt;string&gt; vs {\"red\", \"green\", \"blue\", \"green\"};2for (auto p: find_all(vs, \"green\")3\t*p = \"replaced\";RunDon't pay attention to interior organization of iterator. Just know some agreements:\n.begin() and .end()\np++ or p-- for move\n*p for access to element\n::iterator to get iterator, ::const_iterator to get iterator to immutable values\nIterators find their application not only in interaction with collections. For example, stdin and stdout have \"sequential work\" too:1ostream_iterator&lt;string&gt; oo{cout};2int main()3{4\t*oo = \"Hello, \";5\t++oo;6\t*oo = \"world!\\n\";7}Run1istream_iterator&lt;string&gt; ii{cin};2istream_iterator&lt;string&gt; eos{}; // to indicate EOF on ii == eosRunThese iterator types are not often used directly. It's a simple way to use them with std algorithms. For example:1/*2* read in-file, sort words, eliminate duplicates, write resutl to out-file3*/45int main()6{7\tstring from, to;8\tcin &gt;&gt; from &gt;&gt; to;9\t10\tifstream is{from}; // is an istream11\tistream_iterator&lt;string&gt; ii{is};12\tistream_iterator&lt;string&gt; eos{};1314\tofstream os{to}; // is an ostream15\tostream_iterator&lt;string&gt; oo{os, \"\\n\"}; // delimiter1617\tvector&lt;string&gt; b{ii, eos}; // init with iterators18\tsort(b.begin(), b.end());1920\tunique_copy(b.begin(), b.end(), oo);2122\treturn !is.eof() || !os;23}RunWe can shorten the program by using set (ordered, that uses red-black tree):1int main()2{3\tstring from, to;4\tcin &gt;&gt; from &gt;&gt; to;56\tifstream is{from};7\tofstream os{to};89\tset&lt;string&gt; b {10 istream_iterator&lt;string&gt;{is},11 istream_iterator&lt;string&gt;{},12\t};13\tcopy(b.begin(), b.end(), ostream_iterator&lt;string&gt;{os, \"\\n\"});1415\treturn !is.eof() || !os;16}RunExample for find:1struct GT { // for functor2\tint val;3\tGreater_than(int v): val{v} {}4\tbool operator()(const pair&lt;string,int&gt;&amp; r){5 return r.second&gt;val;6\t}7};89// usage:10map&lt;string, int&gt;&amp; m = ...;11auto p = find_if(m.gebin(), m.end(), GT{42});12// or with lambda:13int cx = count_if(m.begin(), m.end(),14\t[](const pair&lt;string, int&gt;&amp; r){return r.second &gt; 42;}15);RunFeatures of algorithm:\nfiniteness\ndefiniteness\ninput\noutput\neffectiveness\n<br><img alt=\"Screenshot 2025-10-02 at 23.54.37.png\" src=\"a9s/screenshot-2025-10-02-at-23.54.37.png\" target=\"_self\" style=\"width: 600px; max-width: 100%;\">You can provide shorthand for containers to avoid .begin()/.end() calls:1template &lt;class C&gt;2void sort(C&amp; c)3{4\tsort(c.begon(), c.end());5}67template&lt;class C, class Pred&gt;8void sort(C&amp; c, Pred p)9{10\tsort(c.begin(), c.end(), p);11}Run\nUse libraries! (Don't reinvent the wheel)\nHaving choice, prefer std lib against others\nHowever, don't think std is ideal for everything\nDon't forget #include\nDon't forget std::\nPrefer string rather than cstring\niostreams are type sensitive, type-safe, and extensible\nPrefer vector, map, and unordered_map\nKnow concrete containers and their tradeoffs\nUse vector by default\nPrefer compact data structures\nIf in doubt, use a range-checked vector (.at)\nUse push_back or back_inserter to add elements\nUse push_back on a vector rather than realloc() on an array\nCatch common exceptions in main()\nPrefer std algorithms rather than handwritten loops\nIf iterator use gets tedious, define shorthand for container algorithm\nThe main aim of the std library is not \"everything for everyone\". It aims to cover needs of intersection rather than union. That is, std library provides components that are useful to most people in most application areas.The most important aspect of good programs is resource management, and of course the std library is designed to not leak resources.Example, the technique is used for the std library lock classes:1mutex m;2void f()3{4\tunique_lock&lt;mutex&gt; lck{m};5}RunNote\nunique_lock's destructor release the mutex when the thread of control leaves f() (either by return or by throw)\nThis is an application of the RAII technique. This technique is fundamental to the idiomatic handling of resources in C++, and many std libs do so (containers, strings, iostreams and others).To help manage objects allocated on the free store (heap) std &lt;memory&gt; provides two \"smart pointers\":\nunique_ptr to represent unique ownership\nshared_ptr to represent shared ownership\nboth use RAII\nExample of careless programming that may cause memory leaks:Bad code1void f(int i, int j)2{3\tX* p = new X;4\tunique_ptr&lt;X&gt; sp{new X};5\t// ...6\tif (i &lt; 99)7 throw Z{}; // leak by p8\tif (j &lt; 77)9 return; // leak by p10\tp-&gt;do_something();11\tsp-&gt;do_something();12\t// ...13\tdelete p;14}RunIronically, we could have solved the problem simply by not using a pointer and not using new.Smart pointers can be used for passing addresses in/out functions:1unique_ptr&lt;X&gt; make_X(int i)2{3\treturn unique_ptr&lt;X&gt;{new X{i}};4}RunInmportant\nOn passing objects of smart pointer types we have:\nunique_ptr is moved\nshared_ptr is copied\nThe object that is under shared_ptrs control is destroyed when last of its shared_ptrs is destroyed.\nExample:1void f(shared_ptr&lt;fstream&gt;);2void g(shared_ptr&lt;fstream&gt;);34void use(const string&amp; name, ios_base::openmode mode)5{6\tshared_ptr&lt;fstream&gt; fp{new fstream(name, mode)};7\tif (!*fp) throw No_file{};89\tf(fp); // after return unique_ptr fp would be destroyed10\tg(fp); // this call would be unavailable if fp were unique_ptr11\t// ...12}RunUsage of smart pointer is neither cost free nor exorbitantly expensive.In fact, shared_ptrs do not in themselves provide any rules for which of their owners can read/write the shared object.Note\nThe smart pointers don't solve data races and other form of confusion (it's not enough just eliminate the resource management issues).\nNot every time you should use smart pointers (e.g., there is no need when you use containers or thread). Smart pointers are needed when we need pointer semantics:\nwe share an object (maybe with unique ownership)\nwe refer to a polymorphic object (with unique or shared ownership)\nMy own concurrency classification:1concurrency ‚Äî several tasks simultaneously2\tasynchronous ‚Äî 1-2-1-2-1-23\tparallelism - 12-12-124 multithreading - several threads5 multiprocessing - several processesWorth to note\nThe std lib mostly supports system-level concurrency.\nIt does not aim to directly provide sophisticated higher-level concurrency models.\nEven more interesting\nIn fact, on lowest level C++ provides a suitable (for concurrency) memory model and a set of atomic operations ‚Äî it is the basis of the concurrency.\nHowever, most users will see concurrency only in terms of the std lib and higher-level libs.\nMain std lib concurrency facilities:\nthread\nmutex\nlock()\npackaged_task\nfuture C++ concurrency std lib features do not incur performance penalties compared with operating system's offerings def\ntask is a computation that can potentially be executed concurrently. In C++ it is function or functor.\nthread is the system-level representation of a task in a program.\nExample:1void f();23struct F{4\tvoid operator()();5};67void use()8{9\tthread t1{f}; // is launched immediately10\tthread t2{F()}; // is launched immediately1112\tt1.join(); // wait for finish13\tt2.join();14}RunThreads can communicate through shared data, that is typically controlled by locks or other synchronization mechanism.Example of communication:Bad code\nNot synchronized cout\n1int main()2{3\tthread t1{[](){cout &lt;&lt; \"Hello world!\\n\";}};4\tthread t2{[](){cout &lt;&lt; \"Parallel World!\\n\";}};5\tt1.join(); t2.join();6}RunOut is unpredictable!Our main aim in concurrent program is to keep tasks completely separate except where they communicate in simple and obvious way.1void f(vector&lt;double&gt; v);23struct F{4\tvector&lt;double&gt;&amp; v;5\tF(vector&lt;double&gt;&amp; vv) :v(vv) {}6\tvoid operator()();7};89int main()10{11\tvector&lt;double&gt; v1{1,2,3,4,5};12\tvector&lt;double&gt; v2{6,7,8,9,0};13\tthread t1{f, v1}; // copy of v114\tthread t2{F{v2}}; // will work with original v215\tt1.join(); t2.join();16}RunNote\nWith thread t1{f, v1}; the compiler constructs the functor (as Stroustrup says) and stores a copy of v1. On the actual call in the thread, f is invoked with std::move of this copy. Therefore, for f's arguments (without templates and without std::ref), valid parameter types are: T (by value), const T&amp;, and T&amp;&amp;, but not T&amp;, since a true lvalue reference to the original object (and to its copy in thread) is never provided.\nFor return you can pass the location of a place to deposit the result as a separate pointer argument. It is not a particularly elegant way.def\nmutex ‚Äî mutual exclusion object\n1mutex m;2int sh;34void f()5{6\tunique_lock&lt;mutex&gt; lck{m}; // call to m.lock()7\tsh += 7;8} // mutex is released by unique_lock, call to m.unlock()RunCorrespondence based on convention (i.e., which mutex protects which data) ‚Äî error-prone. A better way is to make it clear using various language mechanisms:1class Record{2public:3\tmutex rm;4};RunTo avoid deadlock on acquiring many mutex std lib offers:1void f()2{3\tunique_lock lck1{m1, defer_lock}; // defer_lock ‚Äî special flag (emp str)4\tunique_lock lck2{m2, defer_lock};5\tunique_lock lck3{m3, defer_lock};6\tlock(lck1, lck2, lck3); // smart algorithm to lock all three7} // release all three by unique_lockRunLocking and unlocking are relatively expensive operations. Do not choose shared data for communication between threads solely for \"efficiency\"; on modern machines, it can be faster to copy and pass data between threads. Always measure before assuming shared data is more efficient.\nThe main idea is that you can allow you to copy data to create 2 independent copy for each thread, instead of using shared data.An chrono sleeping example:1using namespace std::chrono; // chrono is a namespace23auto t0 = high_resolution_clock::now();4this_thread::sleep_for(milliseconds{20}); // this_thread is a namespace5auto t1 = high_resolution_clock::now();6cout &lt;&lt; duration_cast&lt;nanoseconds&gt;(t1-t0).count()7\t&lt;&lt; \"nanoseconds passed\\n\";RunFor communicating with external events threads use conditional_variable (using it supports many forms of elegant and efficient sharing, but can be rather tricky). Example:1class Message {...};23queue&lt;Message&gt; q;4condition_variable cond;5mutex mtx;67void consumer()8{9\twhile(true){10 unique_lock&lt;mutex&gt; lck{mtx};11 cond.wait(lck, [](){return !q.empty();}); 12 // ^^^^^^^^^^^^^ release lock and wait signal, then reacquire13 auto m = q.front(); q.pop();14 lck.unlock();15 // process m16\t}17}1819void producer()20{21\twhile(true){22 Message m = ...;23 unique_lock&lt;mutex&gt; lck{mtx};24 q.push(m);25 cond.notify_one();26\t}27}Run<br>See working <a data-tooltip-position=\"top\" aria-label=\"file:///Users/rayskiy7/dev/new_beginning/cpp/Stroustrup_cpp/ch5/prodcons.cpp\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"file:/Users/rayskiy7/dev/new_beginning/cpp/Stroustrup_cpp/ch5/prodcons.cpp\" target=\"_self\">example</a>.The std lib provide a few facilities to allow higher-level of concurrency abstraction:\nfuture and promise\npackaged_task\nasync()\nThey are found in &lt;future&gt;.\n.get() on future may throw an exception (from the system, or transmitted from the task we try .get() from).Schematically:<br>\n<img style=\"max-width:400px; \" class=\"excalidraw-svg excalidraw-embedded-img excalidraw-canvas-immersive is-unresolved\" src=\"blob:/0c7bb108-ff0b-462f-8c5b-49e43e7a3771\" filesource=\"a9s/2025.10.03.md\" w=\"400\" draggable=\"false\" oncanvas=\"false\" target=\"_self\">Example to put in promise:1void f(promise&lt;X&gt;&amp; px)2{3\ttry {4 X res = ...; // compute res5 px.set_value(res);6\t}7\tcatch (...) {8 px.set_exception(current_exception()); // lib func9\t}10}RunExample to get future:1void g(future&lt;X&gt;&amp; fx)2{3\ttry {4 X v = fx.get();5 // use v...6\t}7\tcatch (...) {8 // handle error...9\t}10}RunThis type is provided to simplify setting up tasks connected with futures and promises to be run on threads.For example, consider how to accumulate vector by 2 halves:1double accum(double* beg, double* end, double init)2{3\treturn accumulate(beg, end, init);4}56double comp2(vector&lt;double&gt;&amp; v)7{8\tusing Task_type = double(double*,double*,double);910\tpackaged_task&lt;Task_type&gt; pt0{accum};11\tpackaged_task&lt;Task_type&gt; pt1{accum};12\tfuture&lt;double&gt; f0 {pt0.get_future()};13\tfuture&lt;double&gt; f1 {pt1.get_future()};1415\tdouble* first = &amp;v[0];16\tthread t1 {std::move(pt0), first, first+v.size()/2, 0};17\tthread t2 {std::move(pt1), first+v.size()/2, first+v.size(), 0};18\treturn f0.get() + f1.get();19}RunNote\nWe pass pt0/pt1 in threads by std::move because packaged_task cannot be copied!\nBtw, you should use explicit std:: for avoid compiler warn.\nThe main idea of concurrency is to treat a task as a function that may happen to tun concurrently with other tasks (without more complicated work with shared data).Another way to run task potentially asynchronously:1double comp4(vector&lt;double&gt;&amp; v)2{3\tauto sz = v.size();4\tauto v0 = &amp;v[0], v1=v0+sz/4, v2=v0+sz/2, v3=v0+sz*3/4, v4=v0+sz;56\tauto7 f0 = async(accum, v0, v1, 0.0),8 f1 = async(accum, v1, v2, 0.0),9 f2 = async(accum, v2, v3, 0.0),10 f3 = async(accum, v3, v4, 0.0);11\treturn f0.get()+f1.get()+f2.get()+f3.get();12}Run<br>See full <a data-tooltip-position=\"top\" aria-label=\"file:///Users/rayskiy7/dev/new_beginning/cpp/Stroustrup_cpp/ch5/async.cpp\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"file:/Users/rayskiy7/dev/new_beginning/cpp/Stroustrup_cpp/ch5/async.cpp\" target=\"_self\">example</a>.Warn\nUsing async() you don't even know how many threads will be used, because this function observe available system resources. Don't even think of using async() for tasks that share resources needing locking. async() is not just for parallel computation (and increase performance). It can also be used to spawn a task for user-input, leaving \"main thread\" active with something else!\nThere are not only \"big\" libs, such as containers or I/O.\nOther widely useful components are:\nclock, duration\ntype functions (for gaining info about types), such as iterator_traits and is_arithmetic\npair, tuple\nUse subnamespace std::chrono from &lt;chrono&gt;. Useful names:\nhigh_resolution_clock::now()\nduration_cast&lt;T&gt;(duration)\nDuration::count()\ndef\ntype function is a function that is evaluated at compile-time (takes type as arg, or returns one)\nCompile-time instruments are very efficient for final machine-code!Examples:1constexpr float min = numeric_limits&lt;float&gt;::min(); // from &lt;limits&gt;2constexpr int szi = sizeof(int);3static_assert(numeric_limits&lt;char&gt;::is_signed, \"unsigned chars!\");Rundef\nThis style of programming is called metaprogramming or template metaprogramming (when templates are involved).\nSome algorithms take only random-access iterators (i.e., sort()), and others take forward iterators as well (i.e., for-range).\nSo, we can realize universal sort function to sort container with any type of iterator (random-access or forward). It's convenient to use:1template &lt;class C&gt;2using Iterator_type = typename C::iterator;3template &lt;class IT&gt;4using Iterator_category = typename iterator_traits&lt;IT&gt;::iterator_category;5template &lt;class IT&gt;6using Value_type = typename iterator_traits&lt;IT&gt;::value_type;78template &lt;typename RI&gt; // random-access iterator9void sort_helper(RI beg, RI end, random_access_iterator_tag)10{11 sort(beg, end);12}1314template &lt;typename FI&gt; // forward iterator15void sort_helper(FI beg, FI end, forward_iterator_tag)16{17 vector&lt;Value_type&lt;FI&gt;&gt; v{beg, end};18 sort(v.begin(), v.end());19 copy(v.begin(), v.end(), beg);20}2122template &lt;typename C&gt;23void sort(C &amp;c)24{25 using Iter = Iterator_type&lt;C&gt;;26 sort_helper(c.begin(), c.end(), Iterator_category&lt;Iter&gt;{});27\t// ^^^ here we use tag dispatch technique28}2930void test(vector&lt;string&gt; &amp;v, forward_list&lt;int&gt; &amp;lst)31{ sort(v); sort(lst); }RunNote\ndecltype is inconvenient on line 17 because it yields int&amp; instead of int.\n<br>See full working <a data-tooltip-position=\"top\" aria-label=\"file:///Users/rayskiy7/dev/new_beginning/cpp/Stroustrup_cpp/ch5/unsort.cpp\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"file:/Users/rayskiy7/dev/new_beginning/cpp/Stroustrup_cpp/ch5/unsort.cpp\" target=\"_self\">code</a>.def\ntype predicate is a simple type function that answers a fundamental questions about type.\n&lt;type_traits&gt; provides:\nis_arithmetic, is_class, is_pod, is_literal_type, has_virtual_destructor, is_base_of and others.Example:1template&lt;typename T&gt;2constexpr bool Is_arithmetic()3{4\treturn is_arithmetic&lt;T&gt;::value; // contains true or false5}67// for simple variables:8bool b = Is_arithmetic&lt;int&gt;();910// for restricted type templates11template&lt;typename Scalar&gt;12class complex{13\tScalar re, im;14public:15\tstatic_assert(Is_arithmetic&lt;Scalar&gt;(), \"Arithmetic types only!!\");16\t// ...17};RunThey provides std realizations for many-values plain data objects.1#include &lt;utility&gt; // for type `pair` and others23vector&lt;Record&gt; v{...}; // sorted!4auto er = equal_range(v.begin(), v.end(), Record{\"Reg\"},5\t[](const Record&amp; r1, const Record&amp; r2){return r1.name &lt; r2.name;}6) // returns pair7for (auto p = er.first; p != er.second; ++p)8\tcout &lt;&lt; *p;910auto p = make_pair(Record{\"Gabe\"}, 398); // auto deduce types of elementsRun1tuple&lt;string, int, double&gt; t1(\"Sild\", 123, 3.14);2auto t2 = make_tuple(string(\"Herring\"), 10, 3.14);34// for access:5string s = get&lt;0&gt;(t);6int x = get&lt;1&gt;(t);7// a bit ugly syntax üòûRunHelpful\nPairs and tuples can be assigned and compared (=, ==, &lt;) if their elements can be\nRaw string literal\nStarts with R\"( and ends with )\". Example: R\"(\\d{4}-\\d{2}(-d{2})?)\"\n1#include &lt;regex&gt;2regex pat{R\"(\\d{4}-\\d{2}(-d{2})?)\"};3int lineno = 0;4for (string line; getline(cin, line); ){5\t++lineno;6\tsmatch matches; // smatch - s'match - sub matches7\tif (regex_search(line, matches, pat))8 cout &lt;&lt; lineno &lt;&lt; \": \" &lt;&lt; matches[0] &lt;&lt; '\\n';9}RunIn &lt;cmath&gt; we find usual math functions.Useful utilities:1#include &lt;numeric&gt;2list&lt;double&gt; lst {...};3auto s = accumulate(lst.begin(), lst.end(), 0.0);RunFor complex&lt;ScalarT&gt; the most common math functions are supported, e.g.: +, sqrt, /, pow, and others.C++ std &lt;random&gt; consists of two parts:\nan engine that produces (pseudo) random values\na distribution that maps those values into a mathematical distribution in a range\nConsider the following approach:1using engine = default_random_engine; // type of engine2using distribution = uniform_int_distribution&lt;&gt;; // type of distribution3// `int` is default type from definition ^^45engine re{random_device{}()};6distribution d1_6 {1, 6};7auto gen = bind(d1_6, re); // gen() ‚âà d1_6(re)89cout &lt;&lt; gen() &lt;&lt; endl;RunFor more compact usage you can define your own class:1class Rand_int{2\tdefault_random_engine re;3\tuniform_int_distribution&lt;&gt; dist;4public:5\tRand_int(int low, int high)6 :dist{low, high}, re{random_device{}()} { }7\tint operator()() { return dist(re); }8};910// then11Rand_int gen{0, 10};12gen(); // -&gt; ?RunFor vector arithmetic in C++ predefined valarray class that supports usual arithmetic operations and the most common mathematical functions. For example:1void f(valarray&lt;double&gt;&amp; a, valarray&lt;double&gt;&amp; b)2{3\tvalarray&lt;double&gt; c = a*3.14 + b/a;4\tb += a*3.14;5\tc = abs(c);6\tdouble x = b[7];7\t// ...8}Run\nAlso valarray supports stride access (as python's slices) use RAII\nuse unique_ptr for polymorphic type objects\nuse shared_ptr to refer to shared objects\nuse type-safe mechanisms for concurrency\nminimize the use of shared data\ndon't choose shared data (between threads) because of naive \"efficiency\"\nthink in terms of tasks, rather than threads\na lib doesn't have to be large or complicated to be useful\ntime your programs before making claims about efficiency\nyou can write code to explicitly depend on properties of types\nuse regex\ndon't try serious numeric computation using only the language; use libs\nproperties of numeric types are accessible through numeric_limits\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Part I ‚Äî Introduction","level":1,"id":"Part_I_‚Äî_Introduction_0"},{"heading":"1. Notes to the Reader","level":2,"id":"1._Notes_to_the_Reader_0"},{"heading":"The Design of C++","level":3,"id":"The_Design_of_C++_0"},{"heading":"Suggestions for C Programmers","level":3,"id":"Suggestions_for_C_Programmers_0"},{"heading":"The 2011 Standard","level":3,"id":"The_2011_Standard_0"},{"heading":"Standard Library","level":3,"id":"Standard_Library_0"},{"heading":"What is C++ used for?","level":3,"id":"What_is_C++_used_for?_0"},{"heading":"Advice","level":3,"id":"Advice_0"},{"heading":"2. A Tour of C++: The Basics","level":2,"id":"2._A_Tour_of_C++_The_Basics_0"},{"heading":"The Basics","level":3,"id":"The_Basics_0"},{"heading":"Types, Variables, Arithmetic","level":3,"id":"Types,_Variables,_Arithmetic_0"},{"heading":"Constants","level":3,"id":"Constants_0"},{"heading":"Pointers, Arrays, and Loops","level":3,"id":"Pointers,_Arrays,_and_Loops_0"},{"heading":"Structures","level":3,"id":"Structures_0"},{"heading":"Classes","level":3,"id":"Classes_0"},{"heading":"Enumerations","level":3,"id":"Enumerations_0"},{"heading":"Modularity","level":3,"id":"Modularity_0"},{"heading":"Namespaces","level":3,"id":"Namespaces_0"},{"heading":"Exceptions","level":3,"id":"Exceptions_0"},{"heading":"Invariants","level":3,"id":"Invariants_0"},{"heading":"Assertions","level":3,"id":"Assertions_0"},{"heading":"Advice","level":3,"id":"Advice_1"},{"heading":"3. A tour of C++: Abstraction Mechanisms","level":2,"id":"3._A_tour_of_C++_Abstraction_Mechanisms_0"},{"heading":"Introduction","level":3,"id":"Introduction_0"},{"heading":"An Arithmetic Type","level":3,"id":"An_Arithmetic_Type_0"},{"heading":"A container","level":3,"id":"A_container_0"},{"heading":"Initializing Containers","level":3,"id":"Initializing_Containers_0"},{"heading":"Abstract Types","level":3,"id":"Abstract_Types_0"},{"heading":"Virtual Functions","level":3,"id":"Virtual_Functions_0"},{"heading":"Class Hierarchies","level":3,"id":"Class_Hierarchies_0"},{"heading":"Copy and Move","level":3,"id":"Copy_and_Move_0"},{"heading":"Copying Containers","level":3,"id":"Copying_Containers_0"},{"heading":"Moving Containers","level":3,"id":"Moving_Containers_0"},{"heading":"Resource Management","level":3,"id":"Resource_Management_0"},{"heading":"Suppressing Operations","level":3,"id":"Suppressing_Operations_0"},{"heading":"Templates","level":3,"id":"Templates_0"},{"heading":"Parameterized Types","level":3,"id":"Parameterized_Types_0"},{"heading":"Function Templates","level":3,"id":"Function_Templates_0"},{"heading":"Function Objects","level":3,"id":"Function_Objects_0"},{"heading":"Variadic Templates","level":3,"id":"Variadic_Templates_0"},{"heading":"Aliases","level":3,"id":"Aliases_0"},{"heading":"Advice","level":3,"id":"Advice_2"},{"heading":"4. A Tour of C++: Containers and Algorithms","level":2,"id":"4._A_Tour_of_C++_Containers_and_Algorithms_0"},{"heading":"Standard-Library Overview","level":3,"id":"Standard-Library_Overview_0"},{"heading":"The Standard-library Headers and Namespace","level":3,"id":"The_Standard-library_Headers_and_Namespace_0"},{"heading":"Strings","level":3,"id":"Strings_0"},{"heading":"Output","level":3,"id":"Output_0"},{"heading":"Input","level":3,"id":"Input_0"},{"heading":"I/O of User-Defined Types","level":3,"id":"I/O_of_User-Defined_Types_0"},{"heading":"Vector","level":3,"id":"Vector_0"},{"heading":"List","level":3,"id":"List_0"},{"heading":"Map","level":3,"id":"Map_0"},{"heading":"Container Overview","level":3,"id":"Container_Overview_0"},{"heading":"Algorithms","level":3,"id":"Algorithms_0"},{"heading":"Use if Iterators","level":3,"id":"Use_if_Iterators_0"},{"heading":"Stream iterators","level":3,"id":"Stream_iterators_0"},{"heading":"Predicates","level":3,"id":"Predicates_0"},{"heading":"Algorithm Overview","level":3,"id":"Algorithm_Overview_0"},{"heading":"Advice","level":3,"id":"Advice_3"},{"heading":"5. A Tour of C++: Concurrency and Utilities","level":2,"id":"5._A_Tour_of_C++_Concurrency_and_Utilities_0"},{"heading":"Resource Management","level":3,"id":"Resource_Management_1"},{"heading":"<code class=\"code-styler-inline\">unique_ptr</code> and <code class=\"code-styler-inline\">shared_ptr</code>","level":3,"id":"`unique_ptr`_and_`shared_ptr`_0"},{"heading":"Concurrency","level":3,"id":"Concurrency_0"},{"heading":"Tasks and <code class=\"code-styler-inline\">thread</code>s","level":3,"id":"Tasks_and_`thread`s_0"},{"heading":"Passing Arguments","level":3,"id":"Passing_Arguments_0"},{"heading":"Returning Results","level":3,"id":"Returning_Results_0"},{"heading":"Sharing Data","level":3,"id":"Sharing_Data_0"},{"heading":"Waiting for Events","level":3,"id":"Waiting_for_Events_0"},{"heading":"Communicating Tasks","level":3,"id":"Communicating_Tasks_0"},{"heading":"Future and Promise","level":4,"id":"Future_and_Promise_0"},{"heading":"Packaged Task","level":4,"id":"Packaged_Task_0"},{"heading":"Async ‚Äî <code class=\"code-styler-inline\">async()</code>","level":4,"id":"Async_‚Äî_`async()`_0"},{"heading":"Small Utility Components","level":3,"id":"Small_Utility_Components_0"},{"heading":"Time","level":3,"id":"Time_0"},{"heading":"Type Functions","level":3,"id":"Type_Functions_0"},{"heading":"Type Predicates","level":3,"id":"Type_Predicates_0"},{"heading":"Pair and Tuple ‚Äî <code class=\"code-styler-inline\">pair</code>, <code class=\"code-styler-inline\">tuple</code>","level":3,"id":"Pair_and_Tuple_‚Äî_`pair`,_`tuple`_0"},{"heading":"Regular Expressions","level":3,"id":"Regular_Expressions_0"},{"heading":"Math","level":3,"id":"Math_0"},{"heading":"Advice","level":3,"id":"Advice_4"}],"links":["file:///Users/rayskiy7/dev/new_beginning/cpp/Stroustrup_cpp/ch2/helloworld.cpp","engineering/c++-essentials/üîó-—Å++-all-modifiers.html","file:///Users/rayskiy7/dev/new_beginning/cpp/Stroustrup_cpp/ch3/mycomplex.cpp","file:///Users/rayskiy7/dev/new_beginning/cpp/Stroustrup_cpp/ch5/prodcons.cpp","file:///Users/rayskiy7/dev/new_beginning/cpp/Stroustrup_cpp/ch5/async.cpp","file:///Users/rayskiy7/dev/new_beginning/cpp/Stroustrup_cpp/ch5/unsort.cpp"],"author":"","coverImageURL":".","fullURL":"stroustrup-b./tc++pl.-tome-1.html","pathToRoot":"..","attachments":["a9s/screenshot-2025-09-29-at-04.15.37.png","a9s/screenshot-2025-09-29-at-15.56.15.png","a9s/screenshot-2025-10-01-at-02.55.34.png","a9s/screenshot-2025-10-01-at-02.56.03.png","a9s/screenshot-2025-10-02-at-01.51.27.png","a9s/screenshot-2025-10-02-at-23.54.37.png"],"createdTime":1766961847016,"modifiedTime":1766961869451,"sourceSize":51847,"sourcePath":"engineering/compendium/Stroustrup B./TC++PL. Tome 1.md","exportPath":"stroustrup-b./tc++pl.-tome-1.html","showInTree":true,"treeOrder":1,"backlinks":[],"type":"markdown"},"stroustrup-b./tc++pl.-tome-2.html":{"title":"TC++PL. Tome 2","icon":"","description":"Many important things are deemed implementation-defined by the standard. For example:unsigned char c1 = 64; // well defined\nunsigned char c2 = 1256; // implementation-defined, truncation\nOther behaviors are unspecified (e.g., exact value returned by new, or value of a variable assigned to from two threads without synchronization).To maximize portability it is wise to be explicit about implementation-defined provisions. To support such technique, the std lib provides numeric_limits.static_assert(4&lt;=sizeof(int), \"sizeof(int) is too small\");\nConstructions that is undefined by the standard behave very badly:const int size = 4*1024;\nchar page[size];\nvoid f()\n{ page[size+size] = 7; // undefined, may cause disaster\n}\nKinds of implementation:\nhosted includes all the stdlib facilities as described in std\nfreestanding may provide fewer stdlib facilities, as long as the following are provided:\n<img alt=\"Screenshot 2025-10-04 at 04.41.40.png\" src=\"a9s/screenshot-2025-10-04-at-04.41.40.png\" target=\"_self\" style=\"width: 600px; max-width: 100%;\">\nFreestanding implementation is often used for bare-metal programs.\nMany implementations also provide an option for not using exceptions for really minimal, close-to-the-hardware, programs.\nC++ use 7-bit characters set ASCII (ISO 646-1983, ANSI 3.4-1968).\nEvery name (identifier) in C++ has a type!<br>\n<img style=\"max-width:800px; \" class=\"excalidraw-svg excalidraw-embedded-img excalidraw-canvas-immersive is-unresolved\" src=\"blob:/2e045207-4e61-4d79-96ac-1c98a846b91e\" filesource=\"a9s/2025.10.04.md\" w=\"800\" draggable=\"false\" oncanvas=\"false\" target=\"_self\">Booleans are converted to int in expressions (arithmetic and logical):bool b=true;\ncout&lt;&lt;b+5&lt;&lt;endl; // out: 6\nC++ provides a variety of character types:\nchar, signed char, unsigned char, wchar_t, char8_t, char16_t, char32_tDanger\nIt's not safe to assume that the alphabetic characters are contiguous. If your source file is encoded with EBCDIC the test 'a'&lt;c &amp;&amp; c&lt;'z' may be incorrect.\nWarn\nRemember, that C++ leaves open the possibility of existence one's-complement systems; e.g., where char can has values -127...127 (not -128...127) Reminder: most common characters is in range 0...127\nYou cannot cast between pointers to char, unsigned char, signed char ‚Äî because they are three distinct types.<br><img alt=\"Screenshot 2025-10-04 at 20.06.24.png\" src=\"a9s/screenshot-2025-10-04-at-20.06.24.png\" target=\"_self\" style=\"width: 500px; max-width: 100%;\">It's possible but should be avoided:int c = 'ab'; // a='\\0x61' b='\\0x62' -&gt; 0x6162 (big-endian) // 0x6261 (little-endian)\nAdditional char types literals:wchar_t wc = L'ab'; // implementation-defined :(\nchar16_t c16 = u'\\uHHHH'; // 4 bytes char\nchar32_t c32 = U'\\UHHHHHHHH'; // 8 bytes char\nSynonyms:int = signed = signed int\nunsigned = unsigned int\nshort = short int\nlong = long int\nlong long = long long int\nFor more detailed integers you can use &lt;cstdint&gt;:\nint64_t ‚Äî signed int with exactly 64 bits\nuint_fast16_t ‚Äî 16-bit unsigned int, supposedly the fastest such integer\nint_least32_t ‚Äî just like plain int\nand others...\nHex and octal notations sets bits directly and can surprise on some types and machines:// on two's-complement architecture\nint16_t x = 0xffff; // == -1\nint32_t y = 0xffff; // == 65'535\nType of integer literal deduced in order (to first in which can be represented):1347 -&gt; I -&gt; LI -&gt; LLI\n1347L -&gt; LI -&gt; LLI\n1347LL -&gt; LLI\n0... -&gt; I -&gt; UI -&gt; LI -&gt; ULI -&gt; LLI -&gt; ULLI\n0...L -&gt; LI -&gt; ULI -&gt; LLI -&gt; ULLI\n0...LL -&gt; LLI -&gt; ULLI\n...U -&gt; UI -&gt; ULI -&gt; ULLI\n...UL -&gt; ULI -&gt; ULLI\n...ULL -&gt; ULLI\nRemember about scientific notation: 1.2e10 or 1.23e-15<br><img alt=\"Screenshot 2025-10-05 at 01.00.15.png\" src=\"a9s/screenshot-2025-10-05-at-01.00.15.png\" target=\"_self\" style=\"width: 600px; max-width: 100%;\">you can use delimiter:const char* str = R\"x(\"(hello!)\")x\"; // \"(hello!)\"\n// ^ ^ ‚Äî optional delimiter\nCritically to note!\nNote the dramatic difference in the meaning of u prefix for char u'' and string u\"\"!\nFor example, invalid: u'ü§£' (doesn't fit into memory), but valid: u\"ü§£\" (stored as 2 code units of char16_t).\nYou can define your own suffixes (user-defined literals):KM x = 123_km;\nG s = \"hello!\"_gr;\n(use names started with _)string literal suffix:\nstring s = \"hello\"s;\nRemember\nYou should know C++ is not the implementation. The C++ is the standard!\nThink so and avoid implementation-dependent aspects.\nTip\nProgram you don't want to port today may be ported some day! Compatibility is important!\nIt's easier to limit impact of implementation-dependent language feature. Limiting the impact of system-dependent library facilities is far harder. And therefore:Important\nUse std lib wherever feasible!\nThink about your library portability!\nImportant\nsizeof(char) == 1 by definition. You may assume it is 1 byte, but on different machines it may differ!\nGuaranteed about sizes:1byte ‚â° char ‚â§ short ‚â§ int ‚â§ long ‚â§ long long\n1byte ‚â§ bool ‚â§ long\nchar ‚â§ wchar_t ‚â§ long\nfloat ‚â§ double ‚â§ long double\nN ‚â° signed N ‚â° unsigned N char ‚â• 8bits\nshort ‚â• 16bits\nlong ‚â• 32bits\nTo define real values use &lt;limits&gt; (which functions is constexpr) and sizeof.Best practice: avoid conversions that are not value-preserving.alignof(arg); // minimal alignment for correct access in memory // you can also define specific alignment for data\ntemplate&lt;typename T&gt;\nvoid use(const vector&lt;T&gt;&amp; v)\n{ constexpr int bufmax = 1024; alignas(T) char buffer[bufmax]; // uninitialized const int max_els = min(v.size(), bufmax/sizeof(T)); uninitialized_copy(v.begin(), v.begin() + max_els, (T*)buffer);\n}\nRunNote\nalignas(T) align buffer by alignment of T, i.e. by alignof(T)\n<br>see <a data-tooltip-position=\"top\" aria-label=\"file:///Users/rayskiy7/dev/new_beginning/cpp/Stroustrup_cpp/ch6/alignment.cpp\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"file:/Users/rayskiy7/dev/new_beginning/cpp/Stroustrup_cpp/ch6/alignment.cpp\" target=\"_self\">example</a>.The \"value\" of the following is permanent:\ntypes, aliases, templates, functions, constantsWith some simplification, declaration has five parts:\noptional prefix specifiers (static, virtual, ...)\na base type (vector&lt;double&gt;, const int, ...)\na declarator optionally including a name (p[7], *(*)[], ...)\noptional suffix function specifiers (const, noexcept, ...)\nan optional initializer or function body (={7,5,3}, {return x;},...)\nNote\ndeclarations are terminated by ; except for functions and namespaces\n<br><img alt=\"Screenshot 2025-10-05 at 05.47.03.png\" src=\"a9s/screenshot-2025-10-05-at-05.47.03.png\" target=\"_self\" style=\"width: 500px; max-width: 100%;\">Crit\nYou must not use names: starting with _ in global space\nstarting with __ or _C (uppercase) in any space Select descriptive names for large scope symbols and conventional short names for locals.Recommendation\nUse CAPITALIZED names only for macros, not even for constants\nKeywords:<br>\n<img alt=\"Screenshot 2025-10-05 at 18.26.55.png\" src=\"a9s/screenshot-2025-10-05-at-18.26.55.png\" target=\"_self\" style=\"width: 400px; max-width: 100%;\">\nAnd special meaning identifiers:<br>\n<img alt=\"Screenshot 2025-10-05 at 18.27.27.png\" src=\"a9s/screenshot-2025-10-05-at-18.27.27.png\" target=\"_self\" style=\"width: 300px; max-width: 100%;\">Stroustrup says that names of class scope can't be accessed from other translation units unlike namespace's names that can. It is because namespace variables are considered as \"real data\" whereas class's variables are not a real data.Global names are always accessible even within shadowing by global namespace:1int x = 5;2void f(){3\tint x = 7;4\t:: x = 30; // get global x5}RunVery important\nThe scope of a name starts after complete declaration and before initializer. Thus possible:\nvoid f(){int x = x;}\nIt may seems odd, but it makes sense: x contains garbage immediately after declaration.\nThis does not apply to constructors.\nNote\nDeclaration is not an expression.\nDeclaration can't exist without its block {}. For example:\n1if (cond)2\tint x = 5; // error3else4\tfloat y=3; // errorRunForms:1T x1 {v}; // strongly recommended form!2T x2 = {v};3T x3 = v;4T x4(v); // Most vexing parse5// last can be treated as function declaration...RunList initialization (T x1 {v};) does not allow narrowing.A trap\nUsing auto with list initialization can suprise:\nauto x {99}; ‚Äî deduced as initializer_list&lt;int&gt;, not int (Except for C++17!)\nSo, for auto it's better to use =-initialization\ninitializer_list constructor is preferred.Reminder\nstatic objects (global, namespace, local static, static member) are initialized to {} by default!\nIf array or structure is initialized to {}, nested fields are initialized to {} too.Be careful:1T x(); // always function declaration, not empty-args constructorRunauto is used for deducing type on initialization simply. Use for var, const, constexpr\ndecltype() is used for deducing type of something more complicated. It's suitable not only for declarations.Important about auto\nauto often omit references and cv-qualifiers because in expression they are dereferenced and lose cv-qualifiers. So, you may (and need sometimes) do so:\nconst auto&amp; x = ...\nAs I've got on practice:1auto x{1}; // int 12auto x{1, 2}; // ERROR! Ambiguous type34auto x = {1}; // initializer_list&lt;int&gt;5auto x = {1, 2}; // initializer_list&lt;int&gt;6Rundecltype is more \"smart\" and can be used in more specific places (not with specific initializer):1template&lt;class T1, class T2&gt;2auto operator+(const Matrix&lt;T1&gt;&amp; m1, const Matrix&lt;T2&gt;&amp; m2)3-&gt; Matrix&lt;decltype(T1{} + T2{})&gt;4{5\tMatrix&lt;decltype(T1{} + T2{})&gt; res;6\t// ...7}RunConsider 2 properties:\nHas identity ‚Äî the program has the name of, pointer to, or reference to the object\nMovable ‚Äî the object may be moved (to another location without copying, leaving origin location in a valid but unspecified state)\nLet's use i for \"has identity\" and m for \"movable\".\nNote: there are no {i=no, m=no} objects at all (they don't make sense)\nFinally\nWe can precisely describe the C++ language rules:<br>\n<img style=\"max-width:600px; \" class=\"excalidraw-svg excalidraw-embedded-img excalidraw-canvas-immersive is-unresolved\" src=\"blob:/e5ea63f2-7013-4974-b231-279dfd80fbc2\" filesource=\"a9s/2025.10.06.md\" w=\"600\" draggable=\"false\" oncanvas=\"false\" target=\"_self\">\nNote: you use 3 top types in real program\nwhere:\nlvalue - locator value\nglvalue - generalized lvalue\nxvalue - extraordinary, expiring value\nrvalue - read value\nprvalue - pure rvalue Note: Every expression is either an lvalue or an rvalue, but not both.\nObjects classification by lifetime:\nautomatic\nstatic\nfree store\ntemporary objects (temporary objects live until the end of the full expression of which they are part)\nthread-local objects\ndef, note\nfull expression is an expression that is not part of another expression.\nUseful technique:1template&lt;class T&gt;2class vector {3\tusing value_type = T;4\t// ...5}RunIt makes parameter-type T accessible outside: typename Container::value_type. Moreover, now value_type is like namespace member of class vector.Can be generalized with templates:1template &lt;typename T&gt;2\tusing Vector = std::vector&lt;T, My_allocator&lt;T&gt;&gt;;Run\nSpecifiers cannot be applied to type aliases you can see ISO C++\navoid magic constants (like __FILE__)\nprefer char rather than unsigned char or signed char\navoid multiple declaration\nprefer {} for init with a named type\nprefer = for init with usage of auto\nuse using type alias for generalization (with an eye to the future)\nuse enum and class for not alias but new type\nThere are machines that cannot to access individual bytes, it is the reason why sizeof(char) if assumed as 1.Suggestion\nFor more compact data you can use: 1. bitwise logic, 2. bit-fields, 3. bitset.\nThere is possibility to point to class members:1struct T{2 int a;3 void f(int a) { cout &lt;&lt; a &lt;&lt; \" \" &lt;&lt; this -&gt; a &lt;&lt; T::a &lt;&lt; endl; };4};56int T::*p = &amp;T::a;7void (T::*fp)(int) = &amp;T::f; // `&amp;` may not be omitted8 // as may be for usual func names (not in class)910int main()11{12\t// usage example:13 T t{4};14 T *tp = &amp;t;15 (t.*p)++;16 (tp-&gt;*fp)(2);17\t// output:18\t// 2 5519}RunNote\nvoid* variable may not be assigned with function pointer or member pointer!\nUse static_cast&lt;TT*&gt;(void_pointer) to get pointer to TargetType(TT).Note\nIn C++ array size must be constant expression.\nReminder:1int arr[10];2arr == &amp;arr[0];3arr = new int[20]; // error! Can't assign to arrayRunTip\nAvoid array in interfaces (e.g., as function arguments)\nThere is no built-in copy operation for arrays (but copy functions are).Note\nWhen you need assignment to a collection use: vector, or array (not []), or valarray\nCaution\nIn old code you may meet char* str = \"some text\"; but in modern C++ it won't be compiled.\nThe reason is: (in C) \"hi\" has type char [3], (in C++) it has type const char [3].\nWOW\nstring literals are statically allocated, so you can:\n1const char *error_message(int i)2{3\t// ...4\treturn \"range error\";5}RunInteresting (you may not assume whether two identical string literals are allocated as one):1const char* p = \"Equal text\";2const char* q = \"Equal text\";3cout &lt;&lt; p==q &lt;&lt; endl; // result is implementation-definedRunFor multiline:1const char* s1 = \"hello\\n\\2world!\\n\";3const char* s2 = \"hello\\n\"4 \"world!\\n\";5const char* s3 = R\"(hello6world7)\";RunFully defined\nR\"***(...)***\" ‚Äî contains custom pattern *** for open and close raw-string literal.\nNote\nStrings have u8\"\" literal, but there is no u8'' Note again: it's valid to point to the element one beyond last (pointers on arrays). Other deviations are UB by the standard.\nYou can declare C-code:1extern \"C\" int strlen(const char*);2// avoids names manglingRunReminder\nIt's not possible to return array from function!\nSo funny ü§£\na[i] == *(a+i) == *(i+a) == i[a]\n–°ommutativity of addition of numbers and pointers allows i[a], but of course you should avoid this in prod Standard prescribes that subtraction of pointers is defined only when both pointers point to elements of the same array (and does not check that fact!)\nImportant\nrange-for works for a known-size arrays\n1void init(char&amp; x);23int main(){4 const int N = 7;5 char arr[N];6 for (auto&amp; x: arr)7 init(x);8}RunNote\nSome compilers suggest range checking, but avoid it in production\nWarning\noperator, (comma) is not allowed in constant expression:\nint arr[3, 5]; // ERROR!\nSome words about multidimensional arrays\nFirst, reminder:\n1void f(int arr[3][5]); ‚â° void f(int arr[][5]); ‚â° void f(int (*arr)[5]);Run\nSecond, techninque:\n1void process(int* m, int dim1, int dim2){2\tfor (int i=0; i&lt;dim1; i++)3 for (int j=0; j&lt;dim2; j++)4 do_smth(m[i*dim2 + j]); // not m[i][j]5}Run\nThird, don't be fooled by C's variable-length arrays (VLA):\n1void f(int dim1, int dim2, int arr[dim1][dim2]); // ERRORRunRemember\nIn C++ any array must have constexpr length. No non-const var can be used!\nNote\nconst values must be initialized on declaration (non extern) Note that const modifies a type, it restricts the ways of use, rather than specifying how the constants is to be allocated.\nRemember: a pointer may be nullptr or point to an unexpected object.\nReference always refers to object to which it was initialized. There is not nullref\nReferences is divided on:\nlvalue references\nconst references\nrvalue references\nPossibly:1extern int&amp; a; // legal: initialized elsewhereRunNeed to know\nWe cannot have a pointer to a reference. We cannot define an array of references. In that sense, a reference is not an object.\nIllustration for code:1int var = 0;2int&amp; rr{var};3++rr;4int* pp = &amp;rr; // == &amp;var, not &amp;rr (there is no rr indeed)Run<br><img alt=\"Screenshot 2025-10-07 at 03.03.28.png\" src=\"a9s/screenshot-2025-10-07-at-03.03.28.png\" target=\"_self\" style=\"width: 500px; max-width: 100%;\">The initializer for a const T&amp; need not be an lvalue or even of type T. In such case:\nFirst, implicit type conversion to T is applied if necessary\nThen, the resulting value is placed on a temporary variable of type T\nFinally, this temporary variable is used as the value of the initializer\nSo, you can:\n1const double&amp; cdr{1}; // double tmp = double{1}; const double&amp; cdr {temp};Runnote: lifetime of tmp longs until the end of its reference's scope.Recommendation: if you're going to modify T&amp; arg in function, function's name should give a strong hist that the reference argument is modified.You can return T&amp; from functions to provide access to modify some object. For example:1template&lt;class K, class V&gt;2class Map{3public:4\tV&amp; operator[](const K&amp; v); // return res. Then you can: res = ...5\t// ...6};RunConsider common swap:1template&lt;class T&gt;2void swap (T&amp; a, T&amp; b){3\tT tmp{a};4\ta = b;5\tb = tmp;6}RunThere have been made 3 copy operations!\nA better way:1template&lt;class T&gt;2void swap2 (T&amp; a, T&amp; b){3\tT tmp{static_cast&lt;T&amp;&amp;&gt;(a)}; // candidate to move!4\ta = static_cast&lt;T&amp;&amp;&gt;(b); // candidate to move!5\tb = static_cast&lt;T&amp;&amp;&gt;(tmp); // candidate to move!6}RunNote, swap2 can't so: swap2(v, vector&lt;int&gt;{1,2,3});. Solution is to define overloads:1template&lt;class T&gt; void swap2(T&amp;&amp;a, T&amp; b);2template&lt;class T&gt; void swap2(T&amp;a, T&amp;&amp; b);3// now possible:4swap2(v, vector&lt;int&gt;{1,2,3});RunOtherwise, the std lib takes a different approach: it just defines special functions for the most used second argument in swap (duplicate end empty instance):1void f(string&amp; s, vector&lt;int&gt;&amp; v)2{3\t// make s.capacity() == s.size()4\ts.shrink_to_fit(); // or...5\tswap(s, string{s});67\t// clear v8\tv.clear(); // or...9\tswap(v, vector&lt;int&gt;{}); // or...10\tv = {};11}RunFeel difference:1template&lt;class T&gt; class vector{2\t//...3\tvector(const vector&amp; r); // copy constructor (1)4\tvector(vector&amp;&amp; r); // move constructor (2)5};67vector&lt;string&gt; s;8vector&lt;string&gt; s2{s}; // s is lvalue, so use (1)9vector&lt;string&gt; s3{s+\" tail\"}; // expr is rvalue so use (2)RunYes! Move!\nstatic_cast&lt;T&amp;&amp;&gt;(x) has alias std::move(x)\n(where T is typeof(x))\nYeah!\nSince move(x) does not move x (just produces rvalue reference to x), it would have been better if move() had been called rval(), but by now move() has been used for years.\nAlso\nRvalue references can be used to provide perfect forwarding\nConsider interesting example:1using rr = int&amp;&amp;;2using r = int&amp;;34// *reference collapse*5using rr_rr = rr&amp;&amp;; // `int &amp;&amp; &amp;&amp;` -&gt; `int&amp;&amp;`6using rr_r = rr&amp;; // `int &amp;&amp; &amp; ` -&gt; `int&amp;`7using r_rr = r&amp;&amp;; // `int &amp; &amp;&amp; ` -&gt; `int&amp;`8using r_r = r&amp;; // `int &amp; &amp; ` -&gt; `int$`RunSimple mnemonic:\n¬´ lvalue always wins! ¬ª\nThis makes sense: nothing we can do with types can change the fact that an lvalue reference refers to an lvalue.\nnote\nint &amp;&amp; &amp; r = ...; // invalid syntax!\nReference to reference can only happen as the result of an alias or a template type argument!\nRemember\nYou may have reference to pointer int* &amp;p = ...; but you may not have a pointer (and therefore array) to reference.\nBe careful! There is trick to create null-reference, but it generates an error on runtime:1char* ident(char * p) { return p; }2char&amp; r {*ident(nullptr)}; // possible, but disasterRun\navoid nontrivial pointer arithmetic\nprefer not to use multidimensional arrays; use suitable containers instead\nprefer string rather than C-strings\nkeep pointers that represent ownership inside handle classes\nprefer &amp; args over * args, except where \"no object\" is a reasonable option Some operators (e.g., == and !=) are not available by default for structures.\nRule\nAn object of a struct holds its members in the order they are declared. For optimize struct size (due to alignment) you can reorder members from largest to smallest.\nBut usually best to order members for readability.\nEMERGENCY\nUse of multiple access specifiers (public/private/protected) can affect layout!\nRemember about self-reference and cross-reference abilities:1struct B; // incomplete but declared type23struct A{4\tA* a; // possible with a pointer5\tB* b; // possible with a pointer6\tint data;7};89struct B{10\tA* a;11};RunIncomplete type allows many optional (as long as that use does not require members' size of the size of type):1struct S;23extern S a;4S* p;5S f();6void g(S);7S* h(S*);8S* q = h(p);910// ERRORS:11S a;12f();13g(a);14p-&gt;m = 7;RunYou should avoid equality of names of struct and non-struct even while it is possible with disambiguation in C-style:1struct stat {...};2int stat(char* name);34stat(\"hello\"); // is non-struct acceess5struct stat s; // struct access (as in C)RunInfo\nThe same is true for class, union, enum\nMy research:Remember enum is a type (not alias), and simultaneously defines int constants!\nC++ allows nested types (with block-space). So you can define enum or class in function or another class. Structures are classes indeed, but with public members and inheritance by default.\nBy default, structure provide initialization of members in order:1Point p{}; // inited as {0, 0}2Point q{2}; // inited as {2, {}}, i.e. {2, 0}RunYou can define constant size array inside struct (for pass through func) adapted for range-for:1template &lt;typename T, size_t N&gt;2struct array{3\tT elem[N];45\tT* begin() noexcept {return elem;}6\tconst T* begin() const noexcept {return elem;}7\t// ... and a few more89\tconstexpr size_t size() noexcept;10};RunWe can't deduce number of elements:1array&lt;Point&gt; points = {{1,2}, {7,-9}}; // error, N not givenRunKeep in mind Two structures are different types even when have the same members\nAlso invalid: struct S{int x;} s; int i = s;\nEvery struct must have a unique definition (same as function must) def\nplain old data (POD) ‚Äî just data, a contiguous sequence of bytes in memory\nNote\nstd::memcopy typically simply uses a block-move machine instruction (that is very efficient). They should use \"such trick\" only for optimized low-level code and avoid this in higher-level code.\ndef trivially copyable type ‚Äî has trivial copy/move ctors/ops and trivial destructor. Has no virtual functions/bases. Recursively for subobjects.\ntrivial type ‚Äî trivially copyable type with trivial default constructor\nstandard-layout type ‚Äî has no virtual functions/bases. Non-static fields has the same access level. Has no reference-members. Has no non-static data members in more than one base (or in base and in derived). Has no the same type base and first non-static member. You can compile-timed check for time for optimization:1template &lt;typename T&gt;2void mycopy(T* to, const T* from, int count)3{4\tif constexpr(is_pod&lt;T&gt;::value)5 memcpy(to, from, count*sizeof(T));6\telse7 for (int i=0; i!=count; i++)8 to[i]=from[i];9}RunExample:1struct PPN{2\tunsigned int PFN : 22;3\tint : 3; // offset4\tunsigned int CCA : 3;5\tbool nonreachable : 1;6\tbool dirty : 1;7\tbool valid : 1;8\tbool global : 1;9};1011void part_of_VM_system(PPN* p)12{13\t//...14\tif (p-&gt;dirty) { // contents changed15 //copy to disk...16 p-&gt;dirty = 0;17\t}18}RunNote\nType of a bit-field may be only integral or enum.\nExample:1enum Type {str, num};2union Value{3\tchar* s;4\tint i;5};6struct Entry{7\tchar* name;8\tType t;9\tValue v; // use v.s if t==str, v.i otherwise10};Rununion is a kind of a struct which in turn is a kind of a class.\nHowever, there are some restrictions imposed on unions:\nA union cannot have a virtual functions\nA union cannot have members of reference type\nA union cannot have base classes\nA union cannot be used as a base class\nA union has deleted (), ==, =&lt;-, ~() if its member has custom one! UP: I've found that for unnamed union nested in class it behaves not so way.\nAt most one member of a union can have an in-class initializer\nRule (4) is for avoid \"hidden costs\" on derived classes.Rule (5) keeps simple unions simple. For complicated operations it forces the programmer to explicitly provide them. In fact, compiler does not know which constructors or copy operations to call, or which destructors to call.Wow!\nThere is anonymous nested types injection! (see tagged union in example below). 1class Entry{2private:3\tenum class Tag {number, text};4\tTag type; //discriminant5\tunion { // tagged (or discriminated union)6 int i;7 string s;8\t};9public:10\tstruct Bad_entry {}; // for exceptions11\tstring name;1213\t// Many of important are avoided!14\t// ...1516\tvoid set_number(int n)17\t{18 if (type == Tag::text){19 s.~string(); // explicitly destroy string20 type = Tag::number;21 }22 i = n;23\t}2425\tvoid set_text(const string&amp; str)26\t{27 if (type == Tag::text)28 s = str;29 else {30 // placement new: explicitly construct string31 new(&amp;s) string{str};32 type = Tag::text;33 }34\t}35};Run<br>See <a data-tooltip-position=\"top\" aria-label=\"file:///Users/rayskiy7/dev/new_beginning/cpp/Stroustrup_cpp/ch8/anon_union.cpp\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"file:/Users/rayskiy7/dev/new_beginning/cpp/Stroustrup_cpp/ch8/anon_union.cpp\" target=\"_self\">full example</a>.The placement new\nForm of the new that places object in already allocated memory and doesn't cause additional allocation\n1enum class Color{2\tred, // called enumerator3\tgreen,4\tblue5};RunIt's possible to define underlying type for enum:1enum class Warning : char {none=0, green=1, yellow=2, orange=4, red=8};2// sizeof(Warning) == 1RunYou can define operators for enum types:1constexpr Warning operator|(Warning a, Warning b)2{3\treturn static_cast&lt;Warning&gt;(4 static_cast&lt;int&gt;(a) | static_cast&lt;int&gt;(b)5\t);6}RunNote: with constexpr you now can use it in constant expressions:1switch(x){2case Warning::green|Warning::yellow: // for green and yellow3\t...4\tbreak;5}RunWarn: for bool test you need to compare with none:1void f(Warning w)2{3\tif ((w&amp;(Warning::yellow | Warning::orange))!=Warning::none)4 ... // for yellow or orange5}RunIt's possible to declare (not defined awhile) enum class:1enum class Color : char; // declarationRun\nNames injecting can also be called as namespace pollution\nPay the attention!\nYou can declare forwarding declaration enum only with setting the underlying type!\nenum Color; //error!\nenum Color: int; //ok\nThe underlying type for contain values is calculated by range for signed and for unsigned to contain at least min and max enumerators.\nwhen you need to compact data place larger before smaller (for compact alignment)\nuse bit-fields to represent hardware-imposed data layouts\ndon't try naively optimize with bitwise games\nuse unions to save space and never for type conversion\nuse enums to represent sets of named constants\nprefer enum class over plain enum to minimize surprises\ndefine operations on enums for safe and simple use\nNote:\ndeclaration is a statement\nexpression terminated with ; is a statement\nReminder\nThe compiler may reorder code to improve performance as long as the observer behavior persists.\nThere are not so many statements:\n; ‚Äî empty statement\ndeclaration\nexpression;\n{} ‚Äî compound statement or block\ntry {} catch {}\ncase &lt;constexpr&gt; : statement\ndefault : statement\nidentifier : statement\nbreak, continue, goto &lt;identifier&gt;, (throw, but it's not a statement)\nreturn &lt;expression&gt;;\nselection (if, switch)\niteration (for, while, do) Note: = (assignment) and () (function call) are expressions, not statements\nFor condition in test statements argument implicitly converts to bool:\nif (arg) == if(static_cast&lt;bool&gt;(arg))Reminder:1if (cond)2\tint x = val-3; // invalid! You may not only declare. Use {} at leastRunFor for loops we have:11st form:2for3\t(&lt;for-init-statement&gt; [&lt;condition&gt;]; [&lt;expression&gt;])4 &lt;statement&gt;562nd form:7for8\t(&lt;for-init-declaration&gt; : &lt;expression&gt;)9 &lt;statement&gt;\nfor-init-statement may be either a declaration or en expression-statement (both end with a semicolon ;)\nfor-init-declaration must be the declaration of a single uninitialized variable.\nFor tests we have:11st form:2if (&lt;condition&gt;)3\t&lt;statement&gt;452nd form:6while (&lt;condition&gt;)7\t&lt;statement&gt;893rd form:10do &lt;statement&gt;11\twhile (&lt;expression&gt;);\ncondition may be expression or [&lt;init&gt;]; expression.\nif &lt;init&gt; provided, it must declare and init a single variable.\nnote: for do ... while (); you may not to declare in while(...)\nNote\nIt's not possible to repeat the same value in cases:\n1switch (val) {2\tcase 2:3 ...4 break;5\tcase 4-2: // error: multiple usages6 ...7 break;8}RunThe compiler may optimize switches with jump-table or binary-lookup.The compiler often warn if you switch not all enum values:1enum class Color {red, blue, green, black, white, orange, purple};23int main()4{5\textern Color c;6\tswitch(c){7 case Color::red:8 ;break;9 case Color::blue:10 ;break;11 case Color::green:12 ;break;13 case Color::black:14 ;break;15 case Color::white:16 ;break;17 case Color::orange:18 ;break;19 // is `Color::purple` missing?20\t}21}2223// Output:24// ../wl.cpp:10:9: warning: enumeration value 'purple' not handled in switch [-Wswitch]25// 10 | switch(c){26// | ^27// ../wl.cpp:10:9: note: add missing switch cases28// 10 | switch(c){RunNote\nThis type of errors occur when someone adds new enumerator in enum def!\nTip\ntest impossible values separately.\nPay the attention\nScope of different cases' is common! Thus, there is many possible errors:\n1switch (val) {2case 0:3\tint x;4\tint y = 3;5\tstring s;6\t// fallthrough7case 1: // jump bypasses initialization of y, s8\t++x; // warning: using garbage!9\t++y;10\ts = \"nasty!\";11}RunNote:\nfor uninitialized primitives you can use but garbage...\nfor initialized primitives you get a error on compile\nfor all user-defined you get a error on IDE\nTip\nAvoid cross-references between case areas. Ot use additional {} blocks For form for( auto x : v ) {...} object v must provide begin and end in either:\nv.begin(), v.end()\nbegin(v), end(v) Note: element x is *p, where p returned by .begin()\n1for (;;) { // prefer this2\t// infinit loop3}45while () {} // error! expression is expected67while (true) {8\t// infinit loop9}RunNote\ngoto is prohibited for jump past an initializer or into an exception handler!\nNote\ngoto doesn't cause enclosing loop's increment or condition, but correctly exit the scope, thus counter-variable will be destroyed.\nAdvice\nDo not state something in comment, if this is stated in language itself! Don't declare before you have a value to initialize\nPrefer switch ti if when there is a choice\nAvoid goto\nKeep comments crisp (—á–µ—Ç–∫–∏–º–∏)\nState intent in comments\nMaintain a consistent indentation style\nLet's overview the calculator program!\nThere are some important and interesting notes about language facilities and others below.<br>\nFull exercise is done in <a data-tooltip-position=\"top\" aria-label=\"file:///Users/rayskiy7/dev/new_beginning/cpp/Stroustrup_cpp/ch10/calculator.cpp\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"file:/Users/rayskiy7/dev/new_beginning/cpp/Stroustrup_cpp/ch10/calculator.cpp\" target=\"_self\">the file</a>.Recursive descent ‚Äî popular and straightforward top-down technique for syntax analysis.YOU MUST\nYou must declare subsequent function even if its definition is in the same file!\nMost vexing parse (MVP)\nAll that can be interpreted as a function declaration will be so.\nClarifying\nsizeof and C-style cast are operators, not statements.\nreminder, correct forms: sizeof object or sizeof (object)\nsizeof (typename) ‚Äî preferred form\ntypename (expr)\n(typename) expr ‚Äî preferred form In Token_stream we use useful and general technique for classes that hold a pointer to a resource requiring destruction:1Token_stream::Token_stream(istream&amp; s) : ip{&amp;s}, owns{false} {}2Token_stream::Token_stream(istream* p) : ip{p}, owns{true} {}RunStroustrup\nIn general, dealing with complete objects is clearer and less error-prone than manipulating data members individually.\nNext functions use hash-search and are completely efficient!1isalpha(char), isdigit(char), isalnum(char), isspace(char)RunCurious!\nstd::cerr is an unbuffered output stream!\nNew facility ‚Äî Structured bindings\nauto [x, y] = Point{2, 3.8}; // double x = 2, y = 3.8.\nSupported for any object with tuple_size, get, tuple_element\nNote\nIf you don't explicitly return value from func ‚Äî UB, but just warn on compile.\n1int main(int argc, char *argv[]){}RunWith &lt;sstreams&gt; you can use new istringstream{argv[1]}; to form istream from string<br>\nFor more details see <a data-tooltip-position=\"top\" aria-label=\"file:///Users/rayskiy7/dev/new_beginning/cpp/Stroustrup_cpp/ch10/calculator.cpp\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"file:/Users/rayskiy7/dev/new_beginning/cpp/Stroustrup_cpp/ch10/calculator.cpp\" target=\"_self\">main(...)</a>.‚ùóÔ∏èMust see:<br>\n<a data-tooltip-position=\"top\" aria-label=\"‚ûï Operator Summary > By Stroustrup\" data-href=\"‚ûï Operator Summary#By Stroustrup\" href=\"engineering/c++-essentials/‚ûï-operator-summary.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Full Operator Summary</a>Interesting operators for me:1::x // access global x23typeid(type) // type identification4typeid(expr) // run-time type identification5sizeof...(Args) of sizeof...(args) // number of type args or func args67// Forms of alloc/delete:8new type // allocate9new type (expr-list) // allocate and init10new type {expr-list} // allocate and init1112new (expr-list) type // place13new (expr-list) type (expr-list) // place and init14new (expr-list) type {expr-list} // place and init1516delete pointer // dealloc17delete []pointer // dealloc array1819noexcept (expr) // &lt;- not specifier, just evaluatable operator2021// note22object.*ptomem // has lower precedence than object.member (!)23pointer-&gt;*ptomem // has lower precedence than pointer-&gt;member (!)RunNote\nLambdas in C++ is objects of anonymous class with overloaded operator(). Just syntax sugar.\nNote\nUnaries and assignments are right-associative\nOthers are left-associative\nWarning\nA few grammar rules cannot be expressed in terms of precedence (also known as binding strength) and associativity.\nExample: a=b&lt;c?d=e:f=g ‚Äî&gt; a=((b&lt;c)?(d=e):(f=g))\nTip!\nThere is Max Munch rule in C++:\n¬´To make a token the longest possible sequence of characters is chosen¬ª. Example:\n&amp;&amp; ‚Äî&gt; '&amp;&amp;' not '&amp;' '&amp;'\na+++1 ‚Äî&gt; 'a' '++' '+' '1' i.e. (a++) + 1\nAll tokens of C++:<br>\n<img alt=\"Screenshot 2025-10-11 at 19.25.32.png\" src=\"a9s/screenshot-2025-10-11-at-19.25.32.png\" target=\"_self\" style=\"width: 500px; max-width: 100%;\">Result type of arithmetic operators are determined by a set of rules known as¬´The usual arithmetic conversions¬ª\nThe overall aim is to produce a result of the \"largest\" operand type types less than int are converted to int before evaluation.\nlogical operator always produce bool result (but you can override for your class)\nNote!\nThe result is lvalue if it logically feasible:\n1int j = x = y; // (x=y) -&gt; x, not just value of x2int* p = &amp;++x; // (++x) ‚Äî&gt; x, not just value of x3int* q = &amp;(x++); // error! (x++) -&gt; tmp value4int* p2 = &amp;(x&gt;y?x:y); // `?:` ‚Äî&gt; lvalue of largest, not just value5int&amp; r = (x&lt;y)?x:1; // error! `?:` ‚Äî&gt; tmp value because of 1RunOh My God!!!\nUnderflow, overflow, zero-division do not throw exceptions! Result just is UB\nImportant reminder\nThe order of evaluation is undefined!\n1int x = f(2) + g(3); // what is first? f or g?2v[i] = i++; // UB v[i] = i or v[i+1] = i?3f(a(), b()); // UB what is first?RunAttention about temporary objects\nSee dangerous example:\n1void f(string&amp; s1, string&amp; s2, string&amp; s3)2{3\tconst char* cs = (s1+s2).c_str();4\tcout &lt;&lt; cs; // Danger! cs may already point to released memory5\tif (strlen(cs=(s2+s3).c_str())&lt;8 &amp;&amp; cs[0]=='a') { // safe6 // use cs7 // Danger! the same problem8\t}9}Run constexpr may not have side-effects constexpr starts out with integral, floating or enum value constexpr can use some addresses language requires constexpr for array sizes, case labels, and template value arguments for embedded systems you should prefer .rodata because this memory is cheaper (in terms of cost and energy consumption), more plentiful, and immune to most system crashes if something is initialized in compile-time, there can be no data races on that object For C++11 it's only possibility to state return in constexpr function, so you can't use while. It that time sqrt was calculated as:1constexpr int isqrt_helper(int sq, int d, int a)2{ return sq &lt;= a ? isqrt_helper(sq+d, d+2, a) : d; }34constexpr int isqrt(int x)5{ return isqrt_helper(1, 3, x)/2 -1; }RunBut in modern C++ you can:1constexpr int sqrt(int x)2{3\tint base = 1;4\twhile (base*base &lt;= x)5 base++;6\treturn base-1;7}RunTip\nThe parts of ?: or &amp;&amp; or || that is not evaluated may not be an constexpr!\nSome notes by me and AI\nconstexpr in C++20 can do quite a lot, if not everything. Strict rules are not found, but you can think about: transitive chain of constexpr calculations and no access to run-time environment.\nconstexpr works like an interpreter, but clever one (with memoization and other optimizations)\nconsteval is another form of exactly constexpr but with strictly-compile-time evaluation. This can be used only with functions\nif constexpr necessarily executed in compile-time (not recommendation)\nif consteval {...} is special construction for to check how enclosing constexpr function is called (run-time or compile-time)\nconstinit new feature for ensure possibility compile-time initialization. Good for local-static variables (removes overhead of init-check), good for thread_local variables (removes guard usage). The main idea is that const is not an constexpr necessarily\ndef\nliteral type is a class with constexpr constructor\nNote: empty constructor can be considered as constexpr\nFor example, we can:1struct Point{2\tint x,y,z;3\t// const here can be omitted ‚Üì but my compiler says no4\tconstexpr Point up(int h) const { return {x,y,z+h}; }5\tconstexpr Point move(int dx, int dy) const { return {x+dx, y+dy, z}; }6};78constexpr Point orig{0,0}; // -&gt; Point{0,0,0}9constexpr int z = orig.x;1011constexpr Point a[] = {12\torig, Point{1, 1}, Point{2, 2}, orig.move(3,3),13};14constexpr int x = a[1].x;RunIn old time compile-time programming in C++ was impoverished (no functions, only ints).\nIn C++11 we already can more, and even:1template&lt;&gt; class complex&lt;double&gt;{2public:3\texplicit constexpr complex(const complex&lt;long double&gt;&amp;);4\t...5};RunThere is cast-constructor that takes a reference argument!Even more, with modern C++ we can use full-fledged reference operations! For example:1constexpr void f(int&amp; a)2{ a++; }34constexpr int g(){5\tint x = 5; // will be modified in compile-time6\tf(x);7\treturn x;8}910int x = g(); // initialized with 6RunComplicated moment1constexpr const char* str = \"hello\";2constexpr const char* p = str+2; // Stroustrup says it's impossible3constexpr char c = str[2];RunIn fact, char c can be evaluated at compile-time from literal, but address p is unknown. Modern standard is able to understand shifted address as const&lt;str+2&gt;def If you can convert value and then convert the result back to its original type and get the original value, this conversion is called promotion, that is value-preserving conversion.\nIf not, it is narrowing conversion. WOW. You must memorize it forever!\nC++ have implicit promotion for all arithmetic. There are: all types shorter than int are promoted to int\nfor floating-point computations in older versions they were promoted to double Promotions are performed to bring operands to the \"natural\" size for arithmetic operations.Integral promotions. Comprehensive list.\nThey are promoted in order (until first enough space): char, signed char, unsigned char, short, unsigned short ‚Äî&gt; I ‚Äî&gt; UI\nchar16_t, char32_t, wchar_t, enum ‚Äî&gt; I ‚Äî&gt; UI ‚Äî&gt; L ‚Äî&gt; UL ‚Äî&gt; LL ‚Äî&gt; ULL\nbit-field ‚Äî&gt; I ‚Äî&gt; UI\nbool ‚Äî&gt; I\nFundamental types can be implicitly converted into each other in a bewildering number os ways.For integral types:1-&gt; unsigned..., // just take last bits2-&gt; signed..., // implementation-definedRunFor floating types:1src -&gt; dst2// if src can be represented in dst (maybe in adjacent values) ‚Äî OK3// otherwise ‚Äî UBRunFor pointers:1// except func* or &amp;A::member2T* -&gt; void*34// for class B: A5(B*) -&gt; (A*)6(B&amp;) -&gt; (A&amp;)70 -&gt; void*8T* -&gt; const T*9T&amp; -&gt; const T&amp;RunFor boolean:1(*), ints, floats -&gt; boolRun1float -&gt; [trunc] -&gt; int2// if truncated value doesn't fit ‚Äî UB34int -&gt; float5// with some loss of precision if an integral value cannot be6// represented exactly as a value of the floating typeRunYou can manually check to avoid data loss:1char checked_cast(int i)2{3\tchar c = i; // warn: non portable4\tif (i != c) throw std::runtime_error{\"int-to-char check failed\"}5\treturn c;6}RunLet up(T) mean: if either operand is of type T, the other is converted to T\nLet adj(A-&gt;B) mean: if one operand is B and other is A, then if B can represent all the values of A, the A is converted to B.\nRules:\nup(long double) otherwise, up(double)\notherwise, up(float)\notherwise, integral promotion are performed on both operands up(ULL) otherwise, adj(UL-&gt;LL) otherwise both -&gt; ULL\notherwise, adj(U-&gt;L) otherwise both -&gt;UL\notherwise, up(L)\notherwise, up(U)\notherwise both are I\nNote adj is implementation-defined. So, avoid mixing unsigned and signed integers. use raw input only when you have to\nalways verify input\navoid complicated expressions, use ()\navoid order-undefined expressions\navoid narrowing\nRemember, for ?: must be common type to which both operands can be implicitly converted.One interesting use:1int i = (p) ? *p : throw std::runtime_error{\"unexpected nullptr\"};RunReminder\nexpr in expr++ / --expr and others is evaluated once only!\nNote\nx++ and x-- return temporary value, but ++x and --x return lvalue, &amp;x\nNote: prefer std copy over handmaden *p++=*q++\nI've measured real difference. Wow! Timings:\n1// manual_copy (index): 6.87 ms per copy, 138722.29 MB/s2// manual_copy (pointer): 7.07 ms per copy, 134829.35 MB/s3// std::memcpy: 0.15 ms per copy, 6574476.63 MB/s4// std::copy: 0.13 ms per copy, 7333085.66 MB/sRunThe main problems with manually controlled free store:\nLeaked objects\nPremature deletion\nDouble deletion Deletion of a pointer doesn't assign its value to nullptr\nTwo approaches to avoid free-store problems:\nPrefer scoped variables over using free store\nSave pointers from heap in manager object (like vector, string, etc.) ‚Äî RAII\nFrom AI again (incomplete array type, delete[])\nT[] and T[10] are different types. First is deduced to T* in many contexts, but T[10] is known-size whole type.\nTo invoke delete[] p you don't need to know size of array. That size is stored by allocator. But you need to know the type.\nExample of safety array allocation:1void f(int n)2{3\tunique_ptr&lt;int[]&gt; p {new int[n]}; // calls delete[], not delete4\t// ...5\t// automatically destruct p underlying allocated memory6}RunUseful rule of thumb\nNaked new and delete can appear in constructors/destructors only.\nOften external user use new on init of resource handler. For old code with many bad-used new C++ provides std interface to garbage collector\nNote: free storage managers usually use a few additional memory (a couple of words) to store metadata for deallocationNote (Argument Dependent Lookup ADL):1namespace MyLib {2 struct Data {};3 void process(Data); // declared here4}56int main() {7 MyLib::Data d;8 process(d); // found MyLib::process through ADL9}RunThe std implementations of operator new() and operator new[]() don't initialize the memory returned.New information\nIn fact, new may not throw exception when real RAM is exhausted, because there is often virtual memory with swap tables (which gives memory on access, not on allocation).\nYou can define your own new with considering that:1void* operator new(size_t);2// ^^^^^^ necessary arg3T* p = new T;4// ^ implicitly inferred size by sizeof(T)RunAnd then, for example:1void* operator new(size_t n, void* p) noexcept2{3\tcout &lt;&lt; \"custom \\\"placement\\\" allocation\" &lt;&lt; endl;4\t// ... allocate5\treturn p;6}78// usage:9void* buf = reinterpret_cast&lt;void*&gt;(0xF00F);10T* p = new(buf) T;RunNote\nThis code is educational example, in real code it conflict with std global operator new\nThere are placement deletions:1void operator delete(void* p, void*) noexcept;2void operator delete[](void* p, void*) noexcept;RunNote by default do nothing, except possibly inform a garbage collector about deleted pointer\nare possibly called when placement new fails\ndo not call the destructors Advice\nAvoid explicit destructor calls\nnew policy: Both forms new and noexcept new can fail on allocation, the former with throw bad_alloc and the latter with nullptr returned.\nBoth forms can successfully return, but later you can get crash on systems with virtual memory system (with lazy allocation) Note\nnoexcept - keyword, nothrow - predefined const from &lt;new&gt;\nExample of noexcept new:1void f(int n)2{3\tint* p = new(nothrow) int[n];4\tif (p==nullptr) {5 // handle allocation error6\t}7\toperator delete(nothrow, p); // deallocate8}RunExample of unqualified list, which type must be determined from the context:1struct S{int a,b;};2void f(S);34int main()5{ f({1,7}); } // OK: f(S)RunFor ambiguous situation you need to provide concrete type:1struct S{int a,b;};2struct V{double a,b;};34void g(S), g(V); // overloaded56int main()7{8\tg({1,3}); // error: ambiguous9\tg(S{1,3}); // ok: g(S)10\tg(V{1,3}); // ok: g(V)11}RunThree parts of {} implementation model:\nIf used as constructor arguments, it just passes args to constructor. No copy\nIf used as aggregate initialization, each arg is used to initialize element. No copy\nIf used as initializer_list constructor, args are used to init underlying array. Example:1vector&lt;double&gt; v = {1, 2, 3.14};23// is interpreted as:4const double storage[] = {double{1}, double{2}, 3.14};5const initializer_list&lt;double&gt; tmp(storage, sizeof(storage)/sizeof(double));6// ^ private constructor üòû78vector&lt;double&gt; v(tmp);RunTip\ninitializer_list is small object (pointer-like)\ninitializer_list is immutable\nTip\nYou can see on double{3} as on modern way to set type for primitive\nUnqualified list can be used as an expression only as:\nfunc arg\nreturn value\nright-hand operand for =, +=, etc.\nsubscript\ni.e. when type is inferable.\nTo know\nT obj{...}; ‚Äî direct initialization\nT obj = {...}; ‚Äî copy/move initialization\nNote\nType initializer_list cannot be deduced for templates! It is language restriction. Example:\n1template &lt;class T&gt;2void f(T) { }3template &lt;class T&gt;4void g(const vector&lt;T&gt;&amp;) { }56int main() {7\tf({1,2,3}); // error8\tg({1,2,3}); // error9}RunReason: It must be type for initializer-list, but not from.Also know as lambda functions, but strictly speaking incorrectly. Result of lambda expression is called closure object or simply a closure.Form:1auto f = []() mutable noexcept -&gt; type {};2// ^^ ^^^^^^^ ^^^^^^^^ ^^^^^^^ ‚Äî all are optional3// 1 2 3 4RunNotes:\nby default lambda is const\nreturns auto by default (inferred from return expression). If impossible, must be provided\nif you specify 2, 3, or 4; 1 must be specified too.\nAn example:1void print_modulo(const vector&lt;int&gt;&amp; v, ostream&amp; os, int m)2{3\tfor_each(4 begin(v),5 end(v),6 [&amp;os, m] (int x) { if (x%m==0) os &lt;&lt; x &lt;&lt; endl; }7\t);8}RunNote\nUsing [&amp;] (all by reference) may be optimized!\nFor capture this state this explicitly:1[=, this](...){...};2// ^^^^ then in ^ you can use just `field` or `this-&gt;field`RunInteresting feature\nauto f = +[]{cout &lt;&lt; \"hello\\n\";}; will produce function pointer rather than function\nNote\nYou can provide non a functor for for_each, but it fails on compile with long error message, because it sequentially finds for a operator()() [=] and [&amp;] in fact capture only those variable which you use\nSpecial forms:\n[&amp;, a, b] - a and b by value, others by reference\n[=, &amp;a, &amp;b] - a and b by reference, others by value\nLambda with variadics:1template&lt;typename... Var&gt;2void algo(int s, Var... v)3{4\tauto helper = [&amp;s, &amp;v...] { return s*(f(v...)+g(v...)); }5\t// ^^^^ valid6}RunRemember: lambda might outlive its caller. So, using [=] is typically best for passing to another thread.\nThink of the capture list [...] as the initializer list for the closure object\nFor body of lambda you don't need to capture global or namespace variables. They will be bound on lambda body definition time.\nType is closure, function-like object. It is local class type.\nType is unique for each lambda (else template instantiation mechanism might be confused)\nYou can create lambda variable with\nauto or std::function&lt;R(AL)&gt;, where R ‚Äî return type, AL ‚Äî lambda's arguments list\nWow!\nYou can't use auto variable until its type has been deduced!\nSo, option with function allows recursion!Wow!\nThe lambda that captures nothing can be assigned to a pointer to function of an appropriate type!\ndouble (*fp)(double) = [](double a){ return sqrt(a); }\nKinds of explicit conversion:\ntype-safe with {}\nnamed convertions: const_cast\nstatic_cast\nreinterpret_cast\ndynamic_cast C-style casts\nFunctional notation\nStroustrup tend to use homemade conversions with explicit exceptions!1template &lt;class T, class S&gt;2T narrow_cast(S v)3{4\tauto res = static_cast&lt;T&gt;(v);5\tif (static_cast&lt;S&gt;(res)!=v)6 throw runtime_error(\"narrow_cast&lt;&gt;() failed\");7\treturn res;8}RunWarn!\nYou cannot initialize float from non-constexpr int by {}! But it's possible with constexpr (e.g. with literal) that is fit into float: float f{1234}; // OK\nNote\nIn functional style cast you can't use full type without parentheses, use aliases:\n1int* ip; char* cp;2using iptr = int*;34ip = int*(cp); // error!5ip = iptr(cp); // OKRundef\ncast is explicit type conversion Just few reinterpret_cast are portable!\nWarn\nThe result of reinterpret_cast is guaranteed to be usable only if its result is converted back to the exact original type.\nTo know\nreinterpret_cast is the kind of conversion that must be used for pointers to functions.\n(T)expr can cast pointer to obj to pointer to its private base. Never do that!For a built-in types T(expr) is equivalent to (T)expr so it may do cast char* -&gt; int, that is dangerous!\nAny other cases can be non portable!\nPrefer T{v} conversions and named casts!\nprefer ++lv over lv++\nuse resource handles (to avoid leaks, premature or double deletion)\nprefer scoped variables over one has been put on free store\navoid naked new / delete\nUse RAII\nkeep lambdas short and avoid their overuse\nbe careful about reference-capture\nlet the compiler deduce the return type of lambdas\nuse T{v} notation for construction\navoid explicit casts\nprefer named casts\nconsider homemade narrow_cast for safe run-time casts\nStrict rule\nAny name must be declared before its mentioning. No exceptions\nWarn\nThe semantic of argument passing are identical to the semantic of copy initialization! (there can be type checks and implicit types conversions)\nParts:\nname\nparams ()\nreturn type (maybe suffix -&gt; ...)\ninline\nconstexpr\nnoexcept\nstatic and others\n[[noreturn]] to indicate that func will not return using normal mechanism\nand for member-functions: virtual\noverride\nfinal\nstatic\nconst Must know\nDue to C compatibility a const ignored at the highest level of an argument type:\n1void f(int);2void f(const int); // interpreted the same3// These two DO NOT overload each otherRun\nUnnamed and unused arguments ensure that callers are not affected by the change\nSpecial things that follow most rules defined for functions but technically are not functions:\nconstructors don't return value\ncan initialize bases and members\ncan't have their address taken destructors can't be overloaded\ncan't have their address taken functors (function objects) are objects\ncan't be overloaded lambda expressions are shorthand for defining functors Useful! (From AI)\nYou can mark class as final at all: class SomeName final: Base {...}; Conversion functions do not contain return value For void function it is legal: return;\nNote\nSemantic of return (as of args passing) is identical to semantic of copy-init.\nFinally!\nreturn statement initialize a variable of the returned type!\nUseful form for templates:1void f(int* p);2void g(int* p)3{4\t// ...5\treturn g(p); // -&gt;void but we can use f()6}RunExit function:\nreturn\nfalling off the end\nthrow\nuncaught exception in noexcept func calls std::terminate()\ncall to exit() Function that does not return normally can be marked [[noreturn]]\nGood explanation why inline in not strict command, but compiler's hint:\nIf inline func is recursive it may not terminate at all.\nTip\nTo make sure function body has been inlined use constexpr\nInteresting and important!\nTo inline compiler must see definition of inline function (not just have .o file)!\ninline functions have address and their static variables!\nWarn\nIf an inline function is defined in more than one translation unit, its definition in the different translation units must be identical!\nHave the definitions differed across translation units, the compiler would choose one arbitrarily (UB)!\ndef\nconstexpr means ¬´should be usable in a constant expression when given constant expressions as arguments¬ª\nWarn\nRules for constexpr constructors differ over common. There, only simple initialization of members is allowed.\nReminder\nLiteral type is a type with constexpr constructor\nImportant!\nIf some variable is not declared with constexpr but initialized with such one, compiler may interpret its as constexpr for compile-time computations.\nReminder: we can have run-time branches, which are not evaluated at compile time:1constexpr int check(int a)2{3\treturn (low &lt;= a &amp;&amp; a &lt; high) ? a : runtime(a);4}Rundef\nA construct [[...]] is called an attribute. It specifies some implementation-dependent property about the syntactic entity that follows it.\nStd [[noreturn]] indicate that function never returns. If not ‚Äî UB!Reminder\nTo initialize local static only once use constinit\nLocal variables are initialized when execution reaches its definition.Note\nStandard protects local static initialization! It will be initialized only once. But further use-access from many threads is not protected! Avoid recursively defined local static!\nNote\nLocal static variables are useful for avoiding order dependencies among nonlocal variables (the problem is it's unknown which global static is initialized first) Reminder: the scope of a label (out:) is the complete function\n<br>Bible:\nThe semantic of argument passing are copy-init! see: <a data-href=\"‚ö°Ô∏è Initialization\" href=\"engineering/c++-essentials/‚ö°Ô∏è-initialization.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">‚ö°Ô∏è Initialization</a>\nNote, there are:\nspecial rules for passing arrays\nfacility for passing unchecked arguments (c-style variadics)\nfacility for specifying default arguments\nfacility for using {}\nseveral ways of passing to template functions\nIn most cases you should avoid reference-passing arguments, expect for large object for efficiency (then use const T&amp;)\nNote: the arguments passing is not an assignment (in contrast of initialization). It's important for const args, &amp;/&amp;&amp; args, and user-defined types.\nYou need to remember\nLiteral, constant and conversion-requiring arguments can be passed through const T&amp; but not through T&amp;!\nüëÜüèº explanation to study!\nWhen implicit conversion is needed, the compiler may create tmp object! That is why we need const ‚Äî to prevent modification of tmp object!\nSo, you must understand\nCasts do result into tmp! It does not affect the origin\nSo, conversions for non-const reference arguments are disallowed. It helps to avoid the possibility of silly mistakes with temporaries.\nReminder: passing via reference is passing by lvalue-reference!\nNote\nRvalue references are used (in normal way) for changing, so it's extremely rare case of use it with const\nNote\nFor template type T param type T&amp;&amp; is not the same as X&amp;&amp; (with certain X)!\nGeneral ¬´rules of thumb¬ª for arguments passing:\nuse pass-by-value for small objects\nuse pass-by-const-reference to pass large objects for reading only\nreturn rather than modify \"res-param\"\nuse rvalue references to implement move or forwarding\nuse pass-by-pointer if there is \"nothing\" possible (via nullptr)\nuse pass-by-reference only if you have to (pass by pointer is often less obscure and error-prone when you need modifications)\nReminder\nArrays are passed by pointer! In fact, pointer is passed by value\nSomething incredible new!\nYou can pass arrays by reference! It saves the size of an array completely!\n1template&lt;typename T, int N&gt;2void printarr(const T (&amp;arr)[N]){3\tcout &lt;&lt; \"size: \" &lt;&lt; sizeof(arr)/sizeof(T) &lt;&lt; endl; // or just N4 for (const auto&amp; el : arr)5 cout &lt;&lt; el &lt;&lt; \", \";6 cout &lt;&lt;endl;7}RunWarn: there are as many functions generated by compiler as there are calls to printarr with distinct array types.Note\ninitializer_list&lt;T&gt; argument takes priority if there is a possible ambiguity:\n1template&lt;typename T&gt;2void f(initializer_list&lt;T&gt; l) { /*...*/ } // (1)34struct S {int a; string s;};5void f(S s) { /*...*/ } // (2)67template &lt;typename T, int N&gt;8void f(const T (&amp;arr)[N]) { /*...*/ } // (3)910void f(int i) { /*...*/ } // (4)1112int main()13{14\tf({1,2,3}); // calls (1)15\tf({1, 2}); // calls (1)16\tf({1}); // calls (1)17\tf({1, \"hi\"}); // calls (2)!18}RunThere are 3 ways for variadics:\nuse variadic template\nuse initializer_list as argument type\nuse &lt;cstdarg&gt; and ... param Use ... only if you have to. There are many alternatives: overloads, default args, initializer_list, variadic template.\nPossible form\nvoid f (int a ...); // with no ,\nRemind the basic macros for C-style variadics:\nva_list\nva_start\nva_arg\nva_end\nIn-code example:\n1void f(int x, ...)2{3\tva_list ap;4\tva_start(ap, x);5\tchar* str = va_arg(ap, char*); // repeatedly...6\tva_end(ap); // necessary!7}Run1complex::complex(double r, double i): re{r}, im{i} {}2complex::complex(double r): complex{r, 0} {} // interesing!3complex::complex(): complex{0,0} {} // interesting!RunAnd we can even more:1complex::complex(double r={}, double i={}): re{r}, im{i} {}RunNote\nOnly = syntax for defaults!\nFrom AI\nDefaults are substituted in place of calling!\nExample with static default:1class X{2public:3\tstatic int def_arg;4\tvoid f(int =def_arg); // possible without name (!)5\t// In fact, ^^^^^^^ is &amp;X::def_arg6\t//...7};89int X::def_arg = 7;1011void g(X&amp; a)12{13\ta.f(); // f(7) or f(0) (!)14\ta.def_arg = 9;15\ta.f(); // f(9)16}RunSo, advice\nAvoid default arguments that can change value! Default arguments may be provided for trailing arguments only\nDefault argument cannot be repeated or change in the same scope:1void f(int x = 7);2void f(int x = 7); // or = 9 ERROR: redefinition of the default argument34void g()5{6\tvoid f(int x = 9); // valid! Hides global scope declarations 7}RunNote: it's error-prone technique.Important\nWhen the compiler cannot to determine the best match, compile-time error occurs:\n1void print(double);2void print(long);34int main()5{6\tprint(1L); // print(long)7\tprint(1.0); // print(double)8\tprint(1); // error9}RunApproximated rules of AOR (in order):\nExact match (with a few possible trivial conversions: array-&gt;pointer, func-&gt;func*, T-&gt;constT)\nMatch with promotions (bool/char/short -&gt; int, unsigned promotions, float -&gt; double)\nMath with std conversions (e.g., int-&gt;double, double-&gt;int, double-&gt;long double, Derived -&gt; Base, T -&gt; void, int -&gt; unsigned int)\nMatch with user-defined conversions (e.g., double -&gt; complex&lt;double&gt;)\nMatch using the ellipsis ... (c-style) in a function declaration Overloading does not work with return type.\nOverloading works only with an overload set. By default, that means the functions of a single scope.Note\nAny name is searched in sequential order until first match:\nis in local? -[no]-&gt; is in enclosing? -[no]-&gt; is in global?\nIf name is defined, it \"is here\", and then AOR is occurring \"here\", not much more.\nAnd even more info from AI:From standard\nWhen a name is declared in a local scope, it hides any declaration of that name in outer scopes. Hidden declarations are not considered during overload resolution. Example:\n1void f(int);2void f(double);34void g() {5 void f(double);6 f(2); // call f(double)7}89void h() {10\tusing ::f; // pay the attention! it forces to grabs global declarations11 void f(double);12 f(2); // call f(int)13}RunBetween classes in hierarchy (and namespaces) there is no overloading! If you want to, you need use using declarations, directives or Argument-dependent lookup (ADL). For example (provided by AI):1namespace A {2 struct X {};3 void f(X) { std::cout &lt;&lt; \"A::f(X)\\n\"; }4 void g(int) { std::cout &lt;&lt; \"A::g(int)\\n\"; }5}67namespace B {8 struct Y {};9 void f(Y) { std::cout &lt;&lt; \"B::f(Y)\\n\"; }10 void g(double) { std::cout &lt;&lt; \"B::g(double)\\n\"; }11}1213using A::g; // using-declaration14using namespace B; // using-directive1516struct Base {17 void h(int) { std::cout &lt;&lt; \"Base::h(int)\\n\"; }18};1920struct Derived : Base {21 using Base::h; 22 void h(double) { std::cout &lt;&lt; \"Derived::h(double)\\n\"; }23};2425int main() {26 A::X x; B::Y y;2728 f(x); // ADL ‚Üí A::f(X)29 f(y); // ADL ‚Üí B::f(Y)3031 g(42); // using-declaration ‚Üí A::g(int)32 g(3.14); // using-directive ‚Üí B::g(double)3334 Derived d;35 d.h(10); // using Base::h ‚Üí Base::h(int)36 d.h(2.71); // Derived::h(double)37}RunRule is:\nA function that is the best match for one arg and not worse for all others is called.\nConsider ambiguity:1void f(char);2void f(long);34void work(int i)5{6\tf(i); // ?! Ambiguity7}RunYou can solve this with:1inline void f(int i) { f(long{i}); }2// or3f(static_cast&lt;long&gt;(123));RunTip\nYou can appreciate frequently ambiguity error reports as useful indicator of design error\nDocumenting preconditions and postconditions is important! In fact, it is usually hard to check correctness.Hint\nYou can call function by its address. So, dereferencing is optional. Similarly, using &amp; to get address of a function is optional.\nYou can use the nastiest cast reinterpret_cast to change type of a function pointed to:1int (*f)(int*);2void (*g)(void) = reinterpret_cast&lt;void (*)(void)&gt;(f);RunCaution: unpredictable, system-dependent!Warn\nIf function is overloaded, auto can fail on type deducing!\n1auto funcpointer = f; // may fail if f is overloadedRunRemember: pointer to member-function has a quite different semantic.Danger!\nA pointer to a noexcept function should be declared noexcept if you want to preserve useful information:\n1void f(int) noexcept;23void (*fp)(int) noexcept = f;RunYou must\nYou must reflect the linkage of a function in a pointer to it. And it's impossible in alias:\n1using cfp = extern \"C\" void(int); // error!2// ^^^^^^^^^^ must be specifiedRunInteresting\nBecause macros rearrange text of the program before the compiler sees it, they are a major problem for support tools.\nIf you use macros, you can expect inferior service from: debuggers\ncross-reference tools\nprofilers Note\nMacros cannot have: overloads\nrecursion Useful techniques:\n#define CASE break;case\n#define FOREVER for(;;)\n`#define INCR_xx (::xx)++\nTip\nYou should use /* */ comments rather than // in macros for backward compatibility.\nReminder\nTokenizer does its work before preprocessor. Thus, macros work with tokens (not symbols). And the same takes place inside the macro body!\nMacro can be variadic:1#define err_print(...) fprintf(stderr, \"error: %s %d\\n\", __VA_ARGS__)2// __VA_ARGS__ extends to arguments that were actually passed, as a stringRunThe ellipsis ... means that __VA_ARGS__ represents the argumentsPredefined by compiler:\n__cplusplus standard version (and undefined if in C)\n__DATE__ in format: MM dd yyyy\n__TIME__ in format: hh:mm:ss\n__FILE__ path of current source file\n__LINE__ source line number\n__func__ C-style string name of current function\n__STDC_HOSTED__ is 1 if implementation is hosted, and 0 otherwise\nConditionally predefined by implementation:\n__STDC__ is defined in C, is not in C++\n__STDC_MB_MIGHT_NEQ_WC__ is 1 if possibly 'a' != L'a' (for all in basic character set)\n__STDCPP_STRICT_POINTER_SAFETY__ is 1 if the implementation has strict pointer safety\n__STDCPP_THREADS__ is 1 if a program can have more than one thread of execution, is undefined otherwise\nNote\nMost implementations allow a user to define arbitrary macros on the command line or in some other form of compile-time environment. For example define NDEBUG to turn on macro assert(...)\nImplementations often provide additional facilities. Standardized syntax for enabling is:1#pragma ... ... ...Run\nkeep functions short\ndon't reference or point to locals\nuse constexpr if func is compile-time computable\nuse attributes (e.g., [[noreturn]])\nuse const!\nuse initializer_list for similar-typed variable length lists\nwhen overload over integers, provide functions to eliminate ambiguities\nprefer functors and lambdas over function pointers\nuse CAPITALIZED_NAMES for macros Any copyable/movable type is valid to be thrown as exception, but you should use user-defined types!\nThe exception-handling mechanism:\nIs an alternative to traditional techniques (which are insufficient, inelegant, error-prone)\nIs complete; it can be used to handle all errors\nAllows to explicitly separate error-handling code from ordinary code\nSupports a more regular style of error handling\nUser-defined type of exception, example:1struct Range_error{};2void f(int n)3{4\tif (n&lt;0 || n&gt;max) throw Range_error{};5\t// ...6}RunThere are some ways:Note: these ways are not general ;(\nNote: in some programs you will find an unsystematic combination of these approaches(\nTip\nnoexcept explicitly make the desire of terminate on exception\nInteresting\n\"Exceptional\" doesn't mean \"almost never happens\" or \"disastrous\"\nNote\nExceptions are not about asynchronous event. For these events there are defined mechanisms such as signals to deal with asynchrony. They are system-dependent.\nThere are programs that for practical and historical reasons cannot use exceptions. For example:\nIn a time-critical component of an embedded system we must use alternative error-handling methods\nIn a large old programs with naked new/delete you often find no throw/catch\nTwo useful techniques for old programs:\nMimic RAII (with .invalid() that returns error code)\nUse pair&lt;Value, Error_code&gt; on return\nTo know\nThe exception-handling mechanism is inherently nonlocal, so you should: adherence to an overall strategy\ntake simple strategy (otherwise it won't be adhered)\nagree on strategy when development starts Tip\nNot every function should be a firewall Too great work to do\nToo great overhead and tendency to overcheck the same errors\nFunctions from other languages won't obey the rules\nPure local reliability leads to huge complexities Different parts should appear to follow general error-handling strategy even if it internally follows a different strategy. So, sometimes you should convert errno to throw ... and vice versa.\nIn principle (but hard doing so):\nException handling can be implemented without overhead when no exceptions are thrown\nIf exception is thrown, it costs not much more than usual function call\nRemember: traditional methods take not less overhead!With C-functions be careful considering they throw or not any exceptions.def\nexception-safe operation is that which leaves the program in a valid state when throws. Often we think: what is a valid state?\nAvoid implicit invariants! The compiler cannot to discover and maintain then.Std library guarantees (one of the following):\nBasic guarantee for all operations: no leaks.\nThe basic invariant of every built-in and std-lib type guarantee that you can destroy and object or assign to it after every std-lib operation\nStrong guarantee for key operations: operation succeeds or has no effect.\nProvided for key operations, such as push_back(), insert(), or uninitialized_copy()\nNothrow guarantee for some operations: them are guaranteed not to throw an exception.\nProvided for a few simple operations, such as swap() or pop_back()\nIn return, these guarantees are presented on the condition that (all of):\nuser-supplied operations do not leave container elements in invalid states\nuser-supplied operations do not leak resources\ndestructors do not throw exceptions Moreover, an operation that throws an exception must not only leave its operands well-defined states but also ensure that every resource that it acquired is (eventually) released.\n(Often guarded by language facility of destructors on throw) Example of system resources: files, locks, network connections, threads.\nTip (from AI)\nMain idea: don't do releasing manually. Let the compiler do work for you.\nException handling mechanisms is friendly to RAII.Must to know\nDestructors are implicitly called only for objects that were correctly constructed! If your constructor fails, it should restore state of program to primal state as far as possible. It can be achieved by RAII members automatically.\nTip\nIf you need dynamically construct an object, use unique_ptr and shared_ptr for RAII.\nRAII can help to realize finally action:1template &lt;typename F&gt;2struct Final_action {3\tFinal_action(F f): clean{f} {}4\t~Final_action() {clean();}5\tF clean;6};78template &lt;typename F&gt;9Final_action&lt;F&gt; finally(F f)10{ return Final_action&lt;F&gt;{f}; }1112// usage:13int main(){14\tauto fact = finally(15 [](){ cout&lt;&lt;\"finally\"&lt;&lt;endl; } // you can capture here ;)16\t);17\tcout &lt;&lt; \"do work...\" &lt;&lt; endl;18}Run\nNote: it is like an defer in golang\nWhat if precondition fails? There are 2 points of view:\nJust don't do that. Assume that caller ever meet preconditions\nTerminate the program. Just terminate routine\nErrors may be later eliminated by improved design, debugging and testing. First approach improves performance (eliminate millions of tests) but require to deal with many testing errors. Second approach tends to be used in systems where you can just restart (part of a bigger system). In real programs you can find all three ways (exceptions, ingnoring, terminating). You can throw without real expectation of exceptions.Real solution ‚Äî assert!\nchose between compile-time and run-time\nchose action for run-time: throw, ignore, terminate()\nno generate code for assert until there is debug flag, level of checking or mask.\navoid verbose or complicated asserts\nTip\nThe standard offers two simple mechanisms: &lt;cassert&gt; with assert(A) macro working when NDEBUG is undefined. If assertion fails, compiler writes out: cond, func name, file name, line no. and terminates program\nstatic_assert(A, message) provided by language for compile-time\nTip\nAvoid \"ordinary checking code\" like if (debug_level&gt;2 &amp;&amp; ...\n<br>Furthermore, Stroustrup suggest specialized user-defined approach for compile-time omitting high-level assertion. See <a data-tooltip-position=\"top\" aria-label=\"file:///Users/rayskiy7/dev/new_beginning/cpp/Stroustrup_cpp/ch13/massert.cpp\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"file:/Users/rayskiy7/dev/new_beginning/cpp/Stroustrup_cpp/ch13/massert.cpp\" target=\"_self\">code</a>.\nIn C++20 I can suggest more elegant variant:1template &lt;int level = 1&gt;2constexpr void assert(bool cond, const char *message = \"Assertion failed\")3{4 if constexpr (!(level &lt; assertion_level)) // this may truncate func5 return;6 else7 {8 if (cond)9 return;10 if (assertion_mode == Mode::throw_)11 throw runtime_error(message);12 if (assertion_mode == Mode::terminate_)13 terminate();14 }15}RunTip\nIt is wise to have some tests in the final version of a program with the most-important assertion level. For library general code you should prefer reporting errors over terminating.\nYou can throw an exception of any type that can be copied or moved.\nYou cannot throw typename:1throw MyErrorClass; // invalid!RunYou need to know\nOn throw temporary object is created. In process of stack unwinding this object may be copied, moved, or even be untouched (due to the compiler optimizations)\nStroustrup says:\nThe semantics of exception propagation are those of initialization, so objects of types with move semantics are not expensive to throw.\nFrom AI\nRTTI is active only for: exceptions, virtual classes, and maybe for typeid.\nYou can use std-lib exceptions hierarchy (exception, runtime_error, out_of_range, etc.) with inheritance and .what() or just for instantiating.Used for:\nclarity for programmers\noptimization ability for compiler\nImportant\nOn throw from noexcept destructors of calling function are not invoked. Invocation of local (to throw) destructors is implementation-defined.\nFrom AI\nWays to terminate program: exit, quick_exit, terminate, abort.\nReminder!\nnoexcept can be supplied with additional bool: noexcept(true). You can conditionally define it with any constexpr:\ntemplate&lt;typename T&gt;\nvoid action(T&amp; x) noexcept(Is_pod&lt;T&gt;());\nWow again!\nAlso you can use noexcept as operator with expr: noexcept(expr). It looks at all operations in expr and if all are noexcept returns true (false otherwise). It does not evaluate or look inside definitions of those operations.\nIn older C++ code you may find exception specifications:1void f(int) throw(Bad, Worse);2void g(int) throw(); // may not throw, noexcept equivalentRunDeprecated, deleted. Don't use itFor:1void f()2{3\ttry { throw E{}; }4\tcatch (H) {...}5}RunThe handler is invoked if: (unambiguous public base) or If H is a reference and (1) or (2) holds for the type to which H refers Also you can declare H as const Wow\nExceptions require memory.\nIt's guaranteed that there is enough memory to hold out_of_memory exception (whatever strategy of exception placement implementation apply).\nImportant (from AI)\nUse &amp; in catch for using polymorphic types!\nFrom AI\nThere is stack of \"waiting exceptions\" if during an exception handling another occurs.\nInstrument\nthrow; rethrows current_exception() if any, terminate() otherwise.\nWarn\nIf you catch and rethrow Base exception, you have sliced exception. Then caller couldn't have caught Derived exception!\nFor std::exception from &lt;stdexcept&gt; you can catch (exception&amp; err). But for any:1catch(...)RunImportant\nUse correct order of catch clauses: from more specific to more general.\nNew construction:1void f()2try {34} catch (...) {56}RunEspecially useful for constructors:1A::A()2try3\t:member1{...}, member2{...} // (1)4{5\t// ... (2)6} catch (...) {78}Run<br>Note\nIn second case (try before member initializer list :...) if exception occurs in (1) or (2) it would be propagated to caller of constructor (despite we catch)! See <a data-tooltip-position=\"top\" aria-label=\"file:///Users/rayskiy7/dev/new_beginning/cpp/Stroustrup_cpp/ch13/ctorcatch.cpp\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"file:/Users/rayskiy7/dev/new_beginning/cpp/Stroustrup_cpp/ch13/ctorcatch.cpp\" target=\"_self\">more</a>.\nMust to know\nSome already-initialized members will be destructed on exception thrown, others ‚Äî won't be constructed at all.\nUseful techniques:\nDon't throw while handling an exception\nDon't throw if that cannot be caught\nSpecific rules for calling terminate() (take note: C++11):\nno suitable catch\nthrow in noexcept\nwhen destructor throws on stack unwinding\nwhen code on throw propagation throws\nthrow; when there is no current_exception()\nwhen destructor for a statically allocated or thread-local object throws\nwhen init for a statically allocated or thread-local object throws\nwhen a function from atexit() throws\nTake a note\nterminate() call abort(). You can redefine it by set_terminate() from &lt;exception&gt;. For example:\n1using termfunc = void(*)();2[[noreturn]] void my_handler()3{ ... }4termfunc old = set_terminate(my_handler);RunDanger\nIf terminate() is entered, you should assume all program data structures to be corrupted (even cerr). If you try return or throw from terminate ‚Äî abort will be called immediately.\nNote\nabort() indicates abnormal exit. exit() can indicate normal. Don't consider anything about destructors on terminate()\nNote\nThere is no way of catching exceptions thrown during init/del namespace and thread-local variables. (Another reason to avoid globals)\nIf a thread doesn't catch any exception the whole program will be terminated! To avoid use catch(...) or transfer exception to user-thread via current_exception() as packaged_task does:1promise.set_exception(current_exception());Run<br>See full example <a data-tooltip-position=\"top\" aria-label=\"file:///Users/rayskiy7/dev/new_beginning/cpp/Stroustrup_cpp/ch13/vector.cpp\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"file:/Users/rayskiy7/dev/new_beginning/cpp/Stroustrup_cpp/ch13/vector.cpp\" target=\"_self\">here</a>.Useful principles:\nNever let go of a piece of information before its replacement is ready for use\nAlways leave objects in valid states when (re)throwing an exception Even innocent-looking operations might throw (&lt;, =, sort(), etc.)\nProblems you may not sight:\nallocator::allocate may throw if there is no memory left\nT copy-ctor may throw\n(copying of allocator rarely may throw too, if not std)\nImportant techniques from full example:1\t::new (static_cast&lt;void*&gt;(&amp;*p)) T(x);RunPay attention to ::new to access global and &amp;*p for iterator that is not a pointer.Use std-lib implementations:1uninitialized_fill(), uninitialized_fill_n(), uninitialized_copy()RunStroustrup\nException transparency is often the best policy for templates and other \"thin\" layers of software.\nTip\nAll std lib algorithms (e.g. uninitialized_fill, uninitialized_copy, ...) provide important guarantee: sub-objects (bases, members) that have already been completely constructed will be properly destroyed if any exception occurs.\nPay attention\nThere is self-assignment v=v.\nWarn\nstd::copy does not offer the strong exception-safety guarantee. Thus, after unsuccessful operation you might have some elements copied and some not. However, operands still stay in valid state.\nTip\nstd lib vector has more efficient operator= but with weaker exception-safety guarantee (basic)\nMay be useful\nStd lib provide move_if_noexcept\nMy thought\nIf you don't know what to do about exception-safety, on throw try remain object unchanged or at least valid.\nHelpful\nUse ordering and RAII rather than try/except blocks. develop error-handling strategy early in design\nthrow an exception to indicate you can't perform an assigned task\nuse user-defined types for exceptions\nif you cannot use exceptions, mimic them\n<br>always provide the <a data-tooltip-position=\"top\" aria-label=\"Stroustrup B. ‚Äî TC++PL. Tome 3 > 13.2 Exception Guarantees\" data-href=\"Stroustrup B. ‚Äî TC++PL. Tome 3#13.2 Exception Guarantees\" href=\"engineering/book-notes/stroustrup-b.-‚Äî-tc++pl.-tome-3.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">basic guarantee</a>\nalways try for strong guarantee\nlet the constructor establish invariant and throw if it cannot\nrelease locally owned resources before throw\nminimize usage of try/except blocks\nalways prefer compile-time checking\nuse noexcept\ncatch hierarchical exceptions by reference\ndon't assume that every exception is derived from std::exception\nleave operands in valid states before throwing an exception from an assignment\nnever let an exception escape from a destructor\nkeep ordinary code and error-handling one separate\nremember: on throw naked-allocated (new) objects won't be destroyed automatically\nassume that every exception that can be thrown will be thrown\nlibrary should not terminate, use throw and let a caller decide\nlibrary should not log, use throw and let a caller decide\nWe need to cope with name clashes problemExample:1namespace Graphic_lib{2\tclass Shape {...};3\tclass Line : public Shape {...}; // not requires explicit Graphic_lib::4}5namespace Text_lib{6\tclass Line{...};7}RunGood practice\nPlace names in common namespace when they bring similar facilities. Classes are (kinds of) namespaces, but not literally.\n1using std::string; // means 'string' is 'std::string'RunNote\nIt introduces synonym into a scope using can be used with class hierarchies\n1using namespace std;RunOops\nIt works!\n1namespace A{2\tvoid f(){...}3\tvoid afunc(){...}4}5namespace B{6\tvoid f(){...}7\tvoid bfunc(){...}8}910using namespace A;11using namespace B;12afunc(); // OK13bfunc(); // OK14f(); // errorRunFor this automatic kind of lookup, namespace and function must be in scope and declared before ADL.When we call function, we find consequently:\nin enclosing scope\nin namespaces of arguments (including classes and bases)\nExample:1namespace Chrono{2\tclass Date {...};3\tbool operator==(const Date&amp;, const string&amp;);4}56void f(Chrono::Date d, string s)7{8\tif (d==s){ // find in f-scope, then in Chrono:: and std::9 ...10\t}11}RunNote\nThe best match is called\nTo know\nWhen member calls, other members of the same class and its bases are preferred over ADL.\nwarn: operators follow a different rule!\n1namespace N{2\tstruct S{...};3\tvoid f(S);4}5struct Base{6\tvoid f(N::S);7};8struct Derived: Base{9\tvoid g(N::S);10\tvoid work(N::S x)11\t{12 f(x); // Base::f13 g(x); // Derived::g14\t}15};RunStandard says:\nIf arg is a class member, the associated namespaces are the class itself (and its bases) and the class's enclosing namespaces\nIf arg is a namespace member, the associated namespaces are the enclosing namespaces\nIf arg is a built-in type, there are no associated namespaces\nBe careful\nFor members of namespace don't assume it behaves as for classes:\n1namespace N{2\tclass X{...};3\tvoid f(X, int);4}56namespace SomewhereAway{7\tN::X x;8\tvoid f(N::X, unsigned); // won't called9\tvoid work()10\t{11 f(x, 1); // N::f by overload resolution (!)12\t}13}Run\nIf replace namespace to struct it will call SomewhereAway::f\nMy research\nFor unqualified name the compiler uses union () of ordinary lookup and ADL and then overload resolution. Except for: class-member lookup!\nFrom AI:\nYou can use anonymous namespace to hide some names from global\nUseful\nSeparate different kinds of interfaces:\n1namespace Parser { // user interface2\tdouble expr(bool);3}4namespace Parser { // implementer interface5\tdouble prim(bool);6\tdouble term(bool);7\tdouble expr(bool);89\tusing namespace Lexer;10\tusing Error::error;11\tusing Table::table;12}RunSo, we have:<br>\n<img style=\"max-width:400px; \" class=\"excalidraw-svg excalidraw-embedded-img excalidraw-canvas-immersive is-unresolved\" src=\"blob:/6495b05e-e33b-4770-9c02-48a2a5f4d73b\" filesource=\"a9s/2025.10.21.md\" w=\"400\" draggable=\"false\" oncanvas=\"false\" target=\"_self\">Also, we can (but not necessarily) use different names:1namespace Parser {2\tdouble expr(bool);3}4namespace Parser_impl { // changed5\tusing namespace Parser; // key line (!)67\tdouble prim(bool);8\tdouble term(bool);9\tdouble expr(bool);1011\tusing namespace Lexer;12\tusing Error::error;13\tusing Table::table;14}RunSuddenly!\nSyntax for namespace aliases:\n1namespace SomeLongNamedNamespace{ /*...*/ }2namespace slnn = SomeLongNamedNamespace;RunImportant\nIn qualified lookup the compiler should find the composed fields, but for context where you need actual name it is treated as error:\n1namespace N{2 int f();3}45namespace M{6 using N::f; // or using namespace N7}89int M::f(){} // error: 'f' is not actual member of MRunYou can use selection (using-declaration) with over composition (using-directive) to resolve name clashes and ambiguities:1namespace A{2\tint common;3\tint a;4}5namespace B{6\tint common;7\tint b;8}9namespace MyLib{10\tusing namespace A;11\tusing namespace B;1213\tusing A::common; // resolve clash for 'common'14\t// can use a (A::a) and b (B::b)15}RunMy important note:1void work(){2\tusing MyLib::common;3\tprint(common); // OK, prints A::common (1)4}5void work_(){6\tusing namespace MyLib;7\tprint(common); // ‚Äî ERROR (2)8\tprint(MyLib::common); // OK (3)9}RunI've got so:\nUnqualified lookup will gather all names (so we have error in (2))\nQualified lookup does not touch using-directives if not necessary (so all ok in (3))\nReminder\nYou can make template with using:\n1template &lt;typename T&gt;2using Vector = MyLib::Vector&lt;T&gt;;Run\nThe main point is you can use using namespace std; using namespace estd; (extended std) and let the lookup mechanics to find appropriate sort(...)\nWow!1namespace PopularLib{2\tinline namespace V3_2{3 double f(double);4 // ...5\t}6\tnamespace V3_0{7 double f(double);8\t}9}Run\ninline namespace extends to be PopularLib itself, that is, using namespace PopularLib; is equivalent to use using namespace PopularLib::V3_2;\nThere is not the best trick for avoiding disadvantages of inline-versioning:1// V3_common.h2\t// ... lots of declarations ...34// V3_2.h5\tnamespace V3_2{6 double f(double);7 #include \"V3_common.h\"8\t}910// V3_0.h11\tnamespace V3_0{12 double f(double);13 #include \"V3_common.h\"14\t}1516// Popular.h17\tnamespace Popular{18 inline19 #include \"V3_2.h\"20 #include \"V3_0.h\"21 #include ...22\t}Run\nYou should avoid that approach!\nNamespaces can be nested and names lookup works to access enclosing names:1void h();2namespace X{3\tvoid g();4\tnamespace Y{5 void f();6 void ff();7\t}8}910void X::Y::ff()11{12\tf(); g(); h(); // OK13}1415void X::g()16{17\tf(); // no f() in X18\tY::f(); // OK: Y is visible, take Y::f19}RunNote\nNested structures embed their names to enclosing structure (or class).\nBut namespaces never do!\nFinally\nYou can hide some names from outer access:\n1namespace { // inaccessible from outside2\tint a;3\tvoid f() {...}4}56void work()7{8\tcout &lt;&lt; a &lt;&lt; endl; // valid (!)9}RunPay attention!\nThat (!)-line is valid! It's possible because unnamed namespace indeed is extended to:\n1namespace $$${2\t// ...3}4using namespace $$$; // &lt;- WOW!RunTo carefully avoid polluting global namespace C++ wrappers for C (e.g., &lt;cstdio&gt; for &lt;stdio.h&gt;) use using-declarations (not using-directive)\nplace every nonlocal name (except main()) in some namespace\ndesign namespaces avoiding accidentally gaining access to unrelated namespaces (e.g., do not using namespace SomeHugeLib; in your public library namespace)\navoid very short names for namespaces\nuse separate namespaces for interfaces and implementations\nlimit usage of using-directives with: transition, foundational libs (such as std) or within local scopes\ndon't put using-directive in .h files Interesting fact: there are systems that do not use traditional approach: with files.\nKeep in mind\nEven for small change in some dependent file you need to recompile the entire program.\nKeeping program separated by many files allow significantly reduce complete compile time.\ndef\nTranslation unit is a result of preprocessing (i.e. macros done)\nWarning\nLinker is sometimes called a loader\nMy research\nTypes of lib linkage: 1.static linking, 2. dynamic linking, 3. run-time dynamic loading.\n(2) and (3) are also known as load-time dynamic linking and explicit dynamic loading respectively.\nimportant: for both (2) and (3) you need to have declared types in user-program. Moreover, if there is user-defined types in dynlib it's essential to use interfaces (abstract classes) and factory functions.\ndef\nPhysical structure is organization of a program into source files.\nNames of\nfunctions,\nclasses,\ntemplates,\nvariables,\nnamespaces,\nenumerations and enumerators\nmust be used consistently across all translation units (unless the are explicitly specified to be local).\nInteresting note\nAdded linkage specification (e.g., extern \"C\") we have exhaustive list of all top-level entities. My research\nInteresting facts you need to know! Class members are considered declared on class open. Also, member-functions are inline by default:\n1class A{2 public:3 void f(){g();} // you can access g() if it's already declared4 void g(){} // is inline, as well as f()5};RunMust to know!\nconst and constexpr variables have internal linkage by default! It's very important for declarations in .h files. Use extern explicitly for only once occurrence!\nconstexpr functions implicitly have inline, so they can be safely defined in .h Reminder: finally in result you have only functions and variables for external linkage. No types, templates, namespaces or something else.\nLocal variables and other names which compiler does not see are said to have no linkage.Avoid this banned (but possible) construction:1 extern inline int f();2//^^^^^^^^^^^^^ - bad practiceRunFor localization use:\nunnamed namespace\nstatic\nAs a rule of thumb, a header (.h) may contain\nnamed namespace\ninline namespace\ntype def\ntemplate decl or/and def\nfunction decl\ninline function def\nconstexpr function def\ndata decl\nconst and constexpr defs\nenums\nname decl (e.g., class Matrix;)\ntype aliases\nstatic asserts\n#include, #define, #ifdef and other macros\ncomments\nStuffs you should ever avoid in headers:\nordinary function def\ndata def\naggregate def (e.g. short table[] = {1,2,3};)\nunnamed namespace\nusing-directives\nRecommendation: #include only complete defs and decls.In fact, this rule \"ODR\" is phrased in more complicated and subtle manner that they can expect.\nYou may have 2 identical definitions of class/template/inline-func if and only if:\nthey appear in different TU, and\nthey are token-for-token identical, and\nthe meaning of those tokens are the same in both TU\nRemember\nChecking against inconsistent class definitions in separate translation units is beyond the ability of most C++ implementations. So it's up to programer not to violate consistence of type definitions between files.\nNote: for std-lib headers #include&lt;...&gt; may not actually find and paste some text!For every C lib like &lt;LIB.h&gt; in C++ there is &lt;cLIB&gt; header.For:1extern \"C\" char* strcpy(char*, const char*);Run\"C\" does not mean language, but linkage specification only. It may be used for linkage with Fortran or assembly as well (if they conform to the conventions of a C implementation).Note1extern \"C\" int g; // just declaration2extern \"C\" {3\tint g; // (!) definition4\textern int g; // just declaration too, use extern again5}RunSuddenly1namespace MyLib{2\textern \"C\" double f(double);3}RunIn C++ we should use MyLib::f but for linker this name will still be plain f.When linkage is specified for a declaration, the specified linkage applies to all: function types, function names, variable names introduced by the declaration:1typedef int (*FT)(const void*); // FT has C++ linkage2extern \"C\" typedef int (*CFT)(const void*); // CFT has C linkageRunIf something waits for extern-C function pointer, you cannot pass &amp; of C++ function, and vice versa.<br>See <a data-tooltip-position=\"top\" aria-label=\"file:///Users/rayskiy7/dev/new_beginning/cpp/Stroustrup_cpp/ch15/calc_oneh/prg.cpp\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"file:/Users/rayskiy7/dev/new_beginning/cpp/Stroustrup_cpp/ch15/calc_oneh/prg.cpp\" target=\"_self\">full example</a>.<br>See <a data-tooltip-position=\"top\" aria-label=\"file:///Users/rayskiy7/dev/new_beginning/cpp/Stroustrup_cpp/ch15/calc_multh/modules/parser/parser_impl.h\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"file:/Users/rayskiy7/dev/new_beginning/cpp/Stroustrup_cpp/ch15/calc_multh/modules/parser/parser_impl.h\" target=\"_self\">full example</a>. Pay attention to including required dependencies in parser_impl.h header, it's a good practice.Useful tip: you can import each header as deep as it indeed is needed.Tip\nUse multi-header organization for large real programs to separate program into relatively small chunk (as small as possible) which programmer could cover in mind. It allow to maintain easier and compile faster. There is dependency analyzers. You can use this tool.\nInteresting approach: have two public interfaces: for average users, and for expert users.In general, approaches and number of headers are dependent on concrete cases.More often it's impractical and tedious to reorganize program to remove redundant declarations from multiple includes. So, we need find way to allow repeated inclusions of headers.Use the standard solution: #ifndef SOME_HEADER, #define SOME_HEADER, #endifRemember\nThere is no namespaces for macros' names, so prefer long and ugly names! Even having include-guards on each header avoid ubiquitous inclusions! Note: if you define main() without args, you can't then use form with args.\nIf there are global variables or uncaught exceptions things with main() are not so simple.You must know:\nThere is no guaranteed order of globals' initialization among different TU\nThere is no possibility to catch an exception on globals' initialization Several techniques exist for enforcing initialization order for globals among different TU, but none are both portable and efficient.\nRemark\nDynamically linked libraries don't coexist happily with globals (that have complicated dependencies)\nOne useful technique:1int&amp; x() // use ref!2{3\tstatic int x_ = 0;4\treturn x_;5}RunYou have x() that is initialized on first invocation.Caution\nUnfortunately, this technique is not thread-safe.\nKeep in mind\nInitialization of local function static variable (since C++11) is thread-safe. But subsequent operations may cause a data race\nBut...\nGlobal and member static initialization isn't thread safe at all! Use constexpr for compile-time initialization.\nPay attention!\nConstexpr variables initialized by constexpr cannot depend on the values from other TU!\nStd\nThe initialization of a statically allocated object with a constexpr (even implicit) is done at link time!\nTo avoid problems of multi-thread access to statically allocated variable before it have finished its initializations you should:\nminimize use of statically allocated objects\nkeep their initializations as simple as possible\navoid dependencies on dynamically initialized objects in other TU\nOther useful techniques in order:\nuse constexpr for initialize\nif use expressions, make sure they have no side effects\ninitialize in a known single-threaded \"startup phase\" of computation\nuse some form of mutual exclusion\nRepeat ways to terminate:\nreturn from main()\nexit()\nabort()\nthrow an uncaught exception\nviolate noexcept (so terminate())\nquick_exit()\nInfo\nexit(), quick_exit(), abort() are declared in &lt;cstdlib&gt; Stroustrup\nThere are other \"bad\" ways to terminate program, e.g. double_val / 0.0 in some old implementations.\nexit() calls destructors of statically allocated objects (that is useful), but try hard not to call exit() in destructors to avoid infinite recursion. Also, there is atexit(void(*)()). Take action to call on exit(), note: atexit() returns int meaning \"has it had problems?\".Rule\norder: T t1() -&gt; atexit(f) -&gt; T t2() -&gt; exit() -&gt; t2.~T() -&gt; f -&gt; t1.~T()\nquick_exit() and at_quick_exit() are similar, except that destructors are not involved.\ninclude header in file with implementation\ndon't define global entities with the same name and similar-but-different meanings in different TU\navoid non-inline functions defs in headers\nuse #include only for global and namespace scopes\n#include only complete declarations\nuse include guards\nmake headers self-contained (make sure they can be compiled by themselves)\ndistinguish between users' interfaces and implementers' interfaces\navoid nonlocal objects that require run-time init. Especially for code intended for use as part of non-C++ programs\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Part II ‚Äî Basic Facilities","level":1,"id":"Part_II_‚Äî_Basic_Facilities_0"},{"heading":"6. Types and Declarations","level":2,"id":"6._Types_and_Declarations_0"},{"heading":"The ISO C++ Standard","level":3,"id":"The_ISO_C++_Standard_0"},{"heading":"Implementations","level":3,"id":"Implementations_0"},{"heading":"The Basic Source Character Set","level":3,"id":"The_Basic_Source_Character_Set_0"},{"heading":"Types","level":3,"id":"Types_0"},{"heading":"Boolean","level":3,"id":"Boolean_0"},{"heading":"Char","level":3,"id":"Char_0"},{"heading":"Integer","level":3,"id":"Integer_0"},{"heading":"Float","level":3,"id":"Float_0"},{"heading":"Prefixes and Suffixes","level":3,"id":"Prefixes_and_Suffixes_0"},{"heading":"Sizes","level":3,"id":"Sizes_0"},{"heading":"Alignment","level":3,"id":"Alignment_0"},{"heading":"Declarations","level":3,"id":"Declarations_0"},{"heading":"The Structure of Declarations","level":3,"id":"The_Structure_of_Declarations_0"},{"heading":"Names","level":3,"id":"Names_0"},{"heading":"Scope","level":3,"id":"Scope_0"},{"heading":"Initialization","level":3,"id":"Initialization_0"},{"heading":"Missing Initializers","level":3,"id":"Missing_Initializers_0"},{"heading":"Initializer Lists","level":3,"id":"Initializer_Lists_0"},{"heading":"Deducing: <code class=\"code-styler-inline\">auto</code>, <code class=\"code-styler-inline\">decltype()</code>","level":3,"id":"Deducing_`auto`,_`decltype()`_0"},{"heading":"Objects and Values, Lvalues and Rvalues","level":3,"id":"Objects_and_Values,_Lvalues_and_Rvalues_0"},{"heading":"Type Aliases","level":3,"id":"Type_Aliases_0"},{"heading":"Advice","level":3,"id":"Advice_0"},{"heading":"7. Pointers, Arrays, and References","level":2,"id":"7._Pointers,_Arrays,_and_References_0"},{"heading":"Lvalue references","level":3,"id":"Lvalue_references_0"},{"heading":"Rvalue References","level":3,"id":"Rvalue_References_0"},{"heading":"References to References","level":3,"id":"References_to_References_0"},{"heading":"Pointers and References","level":3,"id":"Pointers_and_References_0"},{"heading":"Advice","level":3,"id":"Advice_1"},{"heading":"8. Structures, Unions, and Enumerations","level":2,"id":"8._Structures,_Unions,_and_Enumerations_0"},{"heading":"Structures","level":3,"id":"Structures_0"},{"heading":"<code class=\"code-styler-inline\">struct</code> Layout","level":3,"id":"`struct`_Layout_0"},{"heading":"<code class=\"code-styler-inline\">struct</code> Names","level":3,"id":"`struct`_Names_0"},{"heading":"Structures and Classes","level":3,"id":"Structures_and_Classes_0"},{"heading":"Structures and Arrays","level":3,"id":"Structures_and_Arrays_0"},{"heading":"Plain Old Data (POD)","level":3,"id":"Plain_Old_Data_(POD)_0"},{"heading":"Fields","level":3,"id":"Fields_0"},{"heading":"Unions","level":3,"id":"Unions_0"},{"heading":"Unions and Classes","level":3,"id":"Unions_and_Classes_0"},{"heading":"Enumerations","level":3,"id":"Enumerations_0"},{"heading":"Plain enums","level":3,"id":"Plain_enums_0"},{"heading":"Advice","level":3,"id":"Advice_2"},{"heading":"9. Statements","level":2,"id":"9._Statements_0"},{"heading":"Statement Summary","level":3,"id":"Statement_Summary_0"},{"heading":"Declarations as Statements, and in Conditions","level":3,"id":"Declarations_as_Statements,_and_in_Conditions_0"},{"heading":"Switch statement","level":3,"id":"Switch_statement_0"},{"heading":"Declarations in Cases","level":3,"id":"Declarations_in_Cases_0"},{"heading":"Iteration Statements","level":3,"id":"Iteration_Statements_0"},{"heading":"Comments","level":3,"id":"Comments_0"},{"heading":"Advice","level":3,"id":"Advice_3"},{"heading":"10. Expressions","level":2,"id":"10._Expressions_0"},{"heading":"My notes","level":3,"id":"My_notes_0"},{"heading":"Command-Line Arguments","level":3,"id":"Command-Line_Arguments_0"},{"heading":"Operator Summary ‚ú®","level":3,"id":"Operator_Summary_‚ú®_0"},{"heading":"Results","level":3,"id":"Results_0"},{"heading":"Order of Evaluation","level":3,"id":"Order_of_Evaluation_0"},{"heading":"Temporary Objects","level":3,"id":"Temporary_Objects_0"},{"heading":"Constant Expressions","level":3,"id":"Constant_Expressions_0"},{"heading":"<code class=\"code-styler-inline\">const</code>s in Constant Expressions","level":3,"id":"`const`s_in_Constant_Expressions_0"},{"heading":"Literal Types","level":3,"id":"Literal_Types_0"},{"heading":"Reference Arguments","level":3,"id":"Reference_Arguments_0"},{"heading":"Promotions","level":3,"id":"Promotions_0"},{"heading":"Conversions","level":3,"id":"Conversions_0"},{"heading":"Floating-Integral Conversions","level":3,"id":"Floating-Integral_Conversions_0"},{"heading":"Usual Arithmetic Conversions","level":3,"id":"Usual_Arithmetic_Conversions_0"},{"heading":"Advice","level":3,"id":"Advice_4"},{"heading":"11. Selected Operations","level":2,"id":"11._Selected_Operations_0"},{"heading":"Memory Management","level":3,"id":"Memory_Management_0"},{"heading":"Getting memory space","level":3,"id":"Getting_memory_space_0"},{"heading":"Overloading <code class=\"code-styler-inline\">new</code>","level":3,"id":"Overloading_`new`_0"},{"heading":"No throw new ‚Äî <code class=\"code-styler-inline\">nothrow new</code>","level":3,"id":"No_throw_new_‚Äî_`nothrow_new`_0"},{"heading":"Lists","level":3,"id":"Lists_0"},{"heading":"Lambda Expressions","level":3,"id":"Lambda_Expressions_0"},{"heading":"Alternatives to Lambdas","level":3,"id":"Alternatives_to_Lambdas_0"},{"heading":"Lambda and Lifetime","level":3,"id":"Lambda_and_Lifetime_0"},{"heading":"Namespace Names","level":3,"id":"Namespace_Names_0"},{"heading":"The Type of a Lambda","level":3,"id":"The_Type_of_a_Lambda_0"},{"heading":"Explicit Type Conversions","level":3,"id":"Explicit_Type_Conversions_0"},{"heading":"Construction","level":3,"id":"Construction_0"},{"heading":"Named Casts","level":3,"id":"Named_Casts_0"},{"heading":"C-Style Cast","level":3,"id":"C-Style_Cast_0"},{"heading":"Function Style Cast","level":3,"id":"Function_Style_Cast_0"},{"heading":"Advice","level":3,"id":"Advice_5"},{"heading":"12. Functions","level":2,"id":"12._Functions_0"},{"heading":"12.1 Function Declarations","level":3,"id":"12.1_Function_Declarations_0"},{"heading":"Parts of a Function Declaration","level":4,"id":"Parts_of_a_Function_Declaration_0"},{"heading":"Function Definitions","level":4,"id":"Function_Definitions_0"},{"heading":"Returning Values","level":4,"id":"Returning_Values_0"},{"heading":"Inline Functions","level":4,"id":"Inline_Functions_0"},{"heading":"Constexpr Functions","level":4,"id":"Constexpr_Functions_0"},{"heading":"Constexpr and References","level":4,"id":"Constexpr_and_References_0"},{"heading":"Conditional Evaluation","level":4,"id":"Conditional_Evaluation_0"},{"heading":"Noreturn Functions","level":4,"id":"Noreturn_Functions_0"},{"heading":"Local Variables","level":4,"id":"Local_Variables_0"},{"heading":"12.2 Argument Passing","level":3,"id":"12.2_Argument_Passing_0"},{"heading":"Reference Arguments","level":4,"id":"Reference_Arguments_1"},{"heading":"Array Arguments","level":4,"id":"Array_Arguments_0"},{"heading":"List Arguments","level":4,"id":"List_Arguments_0"},{"heading":"Unspecified Number of Arguments","level":4,"id":"Unspecified_Number_of_Arguments_0"},{"heading":"Default Arguments","level":4,"id":"Default_Arguments_0"},{"heading":"12.3 Overloaded Functions","level":3,"id":"12.3_Overloaded_Functions_0"},{"heading":"Automatic Overload Resolution (AOR)","level":4,"id":"Automatic_Overload_Resolution_(AOR)_0"},{"heading":"Overloading and Return Type","level":4,"id":"Overloading_and_Return_Type_0"},{"heading":"Overloading and Scope","level":4,"id":"Overloading_and_Scope_0"},{"heading":"Resolution for Multiple Arguments","level":4,"id":"Resolution_for_Multiple_Arguments_0"},{"heading":"Manual Overload Resolution","level":4,"id":"Manual_Overload_Resolution_0"},{"heading":"12.4 Pre- and Postconditions","level":3,"id":"12.4_Pre-_and_Postconditions_0"},{"heading":"12.5 Pointer to Function","level":3,"id":"12.5_Pointer_to_Function_0"},{"heading":"12.6 Macros","level":3,"id":"12.6_Macros_0"},{"heading":"Predefined Macros","level":4,"id":"Predefined_Macros_0"},{"heading":"Pragma","level":4,"id":"Pragma_0"},{"heading":"12.7 Advice","level":3,"id":"12.7_Advice_0"},{"heading":"13. Exception Handling","level":2,"id":"13._Exception_Handling_0"},{"heading":"13.1 Error Handling","level":3,"id":"13.1_Error_Handling_0"},{"heading":"Exceptions","level":4,"id":"Exceptions_0"},{"heading":"Traditional Error Handling","level":4,"id":"Traditional_Error_Handling_0"},{"heading":"When You Can't Use Exceptions","level":4,"id":"When_You_Can't_Use_Exceptions_0"},{"heading":"Hierarchical Error Handling","level":4,"id":"Hierarchical_Error_Handling_0"},{"heading":"Exceptions and Efficiency","level":4,"id":"Exceptions_and_Efficiency_0"},{"heading":"13.2 Exception Guarantees","level":3,"id":"13.2_Exception_Guarantees_0"},{"heading":"13.3 Resource Management","level":3,"id":"13.3_Resource_Management_0"},{"heading":"Finally","level":4,"id":"Finally_0"},{"heading":"13.4 Enforcing Invariants","level":3,"id":"13.4_Enforcing_Invariants_0"},{"heading":"13.5 Throwing and Catching Exceptions","level":3,"id":"13.5_Throwing_and_Catching_Exceptions_0"},{"heading":"Throwing Exceptions","level":4,"id":"Throwing_Exceptions_0"},{"heading":"Noexcept Functions","level":4,"id":"Noexcept_Functions_0"},{"heading":"The <code class=\"code-styler-inline\">noexcept</code> Operator","level":4,"id":"The_`noexcept`_Operator_0"},{"heading":"Exception Specification","level":4,"id":"Exception_Specification_0"},{"heading":"Catching Exceptions","level":4,"id":"Catching_Exceptions_0"},{"heading":"Rethrow","level":4,"id":"Rethrow_0"},{"heading":"Catch Every Exception","level":4,"id":"Catch_Every_Exception_0"},{"heading":"Multiple Handlers","level":4,"id":"Multiple_Handlers_0"},{"heading":"Function <code class=\"code-styler-inline\">try</code>-Blocks","level":4,"id":"Function_`try`-Blocks_0"},{"heading":"Termination","level":4,"id":"Termination_0"},{"heading":"Exceptions and Threads","level":4,"id":"Exceptions_and_Threads_0"},{"heading":"13.6 A <code class=\"code-styler-inline\">vector</code> Implementation","level":3,"id":"13.6_A_`vector`_Implementation_0"},{"heading":"A Simple <code class=\"code-styler-inline\">vector</code>","level":4,"id":"A_Simple_`vector`_0"},{"heading":"Representing Memory Explicitly","level":4,"id":"Representing_Memory_Explicitly_0"},{"heading":"Assignment","level":4,"id":"Assignment_0"},{"heading":"Changing Size","level":4,"id":"Changing_Size_0"},{"heading":"Final Thoughts","level":4,"id":"Final_Thoughts_0"},{"heading":"13.7 Advice","level":3,"id":"13.7_Advice_0"},{"heading":"14. Namespaces","level":2,"id":"14._Namespaces_0"},{"heading":"14.1 Composition Problems","level":3,"id":"14.1_Composition_Problems_0"},{"heading":"14.2 Namespaces","level":3,"id":"14.2_Namespaces_0"},{"heading":"Explicit Qualification","level":4,"id":"Explicit_Qualification_0"},{"heading":"<code class=\"code-styler-inline\">using</code> Declarations","level":4,"id":"`using`_Declarations_0"},{"heading":"<code class=\"code-styler-inline\">using</code> Directives","level":4,"id":"`using`_Directives_0"},{"heading":"ADL (Argument-Dependent Lookup)","level":4,"id":"ADL_(Argument-Dependent_Lookup)_0"},{"heading":"14.3 Modularization and Interfaces","level":3,"id":"14.3_Modularization_and_Interfaces_0"},{"heading":"Interfaces and Implementations","level":4,"id":"Interfaces_and_Implementations_0"},{"heading":"14.4 Composition Using Namespaces","level":3,"id":"14.4_Composition_Using_Namespaces_0"},{"heading":"Namespace Aliases","level":4,"id":"Namespace_Aliases_0"},{"heading":"Namespace Composition","level":4,"id":"Namespace_Composition_0"},{"heading":"Composition and Selection","level":4,"id":"Composition_and_Selection_0"},{"heading":"Namespaces and Overloading","level":4,"id":"Namespaces_and_Overloading_0"},{"heading":"Versioning","level":4,"id":"Versioning_0"},{"heading":"Nested Namespaces","level":4,"id":"Nested_Namespaces_0"},{"heading":"Unnamed Namespaces","level":4,"id":"Unnamed_Namespaces_0"},{"heading":"C Headers","level":4,"id":"C_Headers_0"},{"heading":"14.5 Advice","level":3,"id":"14.5_Advice_0"},{"heading":"15. Source Files and Programs","level":2,"id":"15._Source_Files_and_Programs_0"},{"heading":"15.1 Separate Compilation","level":3,"id":"15.1_Separate_Compilation_0"},{"heading":"15.2 Linkage","level":3,"id":"15.2_Linkage_0"},{"heading":"File-Local Names","level":4,"id":"File-Local_Names_0"},{"heading":"Header Files","level":4,"id":"Header_Files_0"},{"heading":"The One-Definition Rule (ODR)","level":4,"id":"The_One-Definition_Rule_(ODR)_0"},{"heading":"Standard-Library Headers","level":4,"id":"Standard-Library_Headers_0"},{"heading":"Linkage to Non-C++ Code","level":4,"id":"Linkage_to_Non-C++_Code_0"},{"heading":"Linkage and Pointers to Functions","level":4,"id":"Linkage_and_Pointers_to_Functions_0"},{"heading":"15.3 Using Header","level":3,"id":"15.3_Using_Header_0"},{"heading":"Single-Header Organization","level":4,"id":"Single-Header_Organization_0"},{"heading":"Multi-Header Organization","level":4,"id":"Multi-Header_Organization_0"},{"heading":"Use of Headers","level":4,"id":"Use_of_Headers_0"},{"heading":"Include Guards","level":4,"id":"Include_Guards_0"},{"heading":"15.4 Programs","level":3,"id":"15.4_Programs_0"},{"heading":"Initialization of Nonlocal Variables","level":4,"id":"Initialization_of_Nonlocal_Variables_0"},{"heading":"Initialization and Concurrency","level":4,"id":"Initialization_and_Concurrency_0"},{"heading":"Program Termination","level":4,"id":"Program_Termination_0"},{"heading":"15.5 Advice","level":3,"id":"15.5_Advice_0"}],"links":["file:///Users/rayskiy7/dev/new_beginning/cpp/Stroustrup_cpp/ch6/alignment.cpp","file:///Users/rayskiy7/dev/new_beginning/cpp/Stroustrup_cpp/ch8/anon_union.cpp","file:///Users/rayskiy7/dev/new_beginning/cpp/Stroustrup_cpp/ch10/calculator.cpp","file:///Users/rayskiy7/dev/new_beginning/cpp/Stroustrup_cpp/ch10/calculator.cpp","engineering/c++-essentials/‚ûï-operator-summary.html","engineering/c++-essentials/‚ö°Ô∏è-initialization.html","file:///Users/rayskiy7/dev/new_beginning/cpp/Stroustrup_cpp/ch13/massert.cpp","file:///Users/rayskiy7/dev/new_beginning/cpp/Stroustrup_cpp/ch13/ctorcatch.cpp","file:///Users/rayskiy7/dev/new_beginning/cpp/Stroustrup_cpp/ch13/vector.cpp","engineering/book-notes/stroustrup-b.-‚Äî-tc++pl.-tome-3.html","file:///Users/rayskiy7/dev/new_beginning/cpp/Stroustrup_cpp/ch15/calc_oneh/prg.cpp","file:///Users/rayskiy7/dev/new_beginning/cpp/Stroustrup_cpp/ch15/calc_multh/modules/parser/parser_impl.h"],"author":"","coverImageURL":".","fullURL":"stroustrup-b./tc++pl.-tome-2.html","pathToRoot":"..","attachments":["a9s/screenshot-2025-10-04-at-04.41.40.png","a9s/screenshot-2025-10-04-at-20.06.24.png","a9s/screenshot-2025-10-05-at-01.00.15.png","a9s/screenshot-2025-10-05-at-05.47.03.png","a9s/screenshot-2025-10-05-at-18.26.55.png","a9s/screenshot-2025-10-05-at-18.27.27.png","a9s/screenshot-2025-10-07-at-03.03.28.png","a9s/screenshot-2025-10-11-at-19.25.32.png"],"createdTime":1767013423996,"modifiedTime":1767013448184,"sourceSize":104413,"sourcePath":"engineering/compendium/Stroustrup B./TC++PL. Tome 2.md","exportPath":"stroustrup-b./tc++pl.-tome-2.html","showInTree":true,"treeOrder":2,"backlinks":[],"type":"markdown"}},"fileInfo":{"kernighan-&-ritchie-‚Äî-c-pl.html":{"createdTime":1758074369052,"modifiedTime":1766965293263,"sourceSize":25323,"sourcePath":"engineering/compendium/Kernighan & Ritchie ‚Äî C PL.md","exportPath":"kernighan-&-ritchie-‚Äî-c-pl.html","showInTree":true,"treeOrder":3,"backlinks":[],"type":"markdown","data":null},"start-page.html":{"createdTime":1767014780778,"modifiedTime":1767016904330,"sourceSize":99,"sourcePath":"engineering/compendium/Start page.md","exportPath":"start-page.html","showInTree":true,"treeOrder":4,"backlinks":[],"type":"markdown","data":null},"stroustrup-b./tc++pl.-tome-1.html":{"createdTime":1766961847016,"modifiedTime":1766961869451,"sourceSize":51847,"sourcePath":"engineering/compendium/Stroustrup B./TC++PL. Tome 1.md","exportPath":"stroustrup-b./tc++pl.-tome-1.html","showInTree":true,"treeOrder":1,"backlinks":[],"type":"markdown","data":null},"stroustrup-b./tc++pl.-tome-2.html":{"createdTime":1767013423996,"modifiedTime":1767013448184,"sourceSize":104413,"sourcePath":"engineering/compendium/Stroustrup B./TC++PL. Tome 2.md","exportPath":"stroustrup-b./tc++pl.-tome-2.html","showInTree":true,"treeOrder":2,"backlinks":[],"type":"markdown","data":null},"site-lib/fonts/94f2f163d4b698242fef.otf":{"createdTime":1767017200399,"modifiedTime":1767017200399,"sourceSize":66800,"sourcePath":"","exportPath":"site-lib/fonts/94f2f163d4b698242fef.otf","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/72505e6a122c6acd5471.woff2":{"createdTime":1767017200400,"modifiedTime":1767017200400,"sourceSize":104232,"sourcePath":"","exportPath":"site-lib/fonts/72505e6a122c6acd5471.woff2","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/2d5198822ab091ce4305.woff2":{"createdTime":1767017200400,"modifiedTime":1767017200400,"sourceSize":104332,"sourcePath":"","exportPath":"site-lib/fonts/2d5198822ab091ce4305.woff2","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/c8ba52b05a9ef10f4758.woff2":{"createdTime":1767017200400,"modifiedTime":1767017200400,"sourceSize":98868,"sourcePath":"","exportPath":"site-lib/fonts/c8ba52b05a9ef10f4758.woff2","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/cb10ffd7684cd9836a05.woff2":{"createdTime":1767017200400,"modifiedTime":1767017200400,"sourceSize":106876,"sourcePath":"","exportPath":"site-lib/fonts/cb10ffd7684cd9836a05.woff2","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/293fd13dbca5a3e450ef.woff2":{"createdTime":1767017200400,"modifiedTime":1767017200400,"sourceSize":105924,"sourcePath":"","exportPath":"site-lib/fonts/293fd13dbca5a3e450ef.woff2","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/085cb93e613ba3d40d2b.woff2":{"createdTime":1767017200400,"modifiedTime":1767017200400,"sourceSize":112184,"sourcePath":"","exportPath":"site-lib/fonts/085cb93e613ba3d40d2b.woff2","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/b5f0f109bc88052d4000.woff2":{"createdTime":1767017200400,"modifiedTime":1767017200400,"sourceSize":105804,"sourcePath":"","exportPath":"site-lib/fonts/b5f0f109bc88052d4000.woff2","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/cbe0ae49c52c920fd563.woff2":{"createdTime":1767017200400,"modifiedTime":1767017200400,"sourceSize":106108,"sourcePath":"","exportPath":"site-lib/fonts/cbe0ae49c52c920fd563.woff2","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/535a6cf662596b3bd6a6.woff2":{"createdTime":1767017200401,"modifiedTime":1767017200401,"sourceSize":111708,"sourcePath":"","exportPath":"site-lib/fonts/535a6cf662596b3bd6a6.woff2","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/70cc7ff27245e82ad414.ttf":{"createdTime":1767017200401,"modifiedTime":1767017200401,"sourceSize":192740,"sourcePath":"","exportPath":"site-lib/fonts/70cc7ff27245e82ad414.ttf","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/454577c22304619db035.ttf":{"createdTime":1767017200401,"modifiedTime":1767017200401,"sourceSize":161376,"sourcePath":"","exportPath":"site-lib/fonts/454577c22304619db035.ttf","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/52ac8f3034507f1d9e53.ttf":{"createdTime":1767017200401,"modifiedTime":1767017200401,"sourceSize":191568,"sourcePath":"","exportPath":"site-lib/fonts/52ac8f3034507f1d9e53.ttf","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/05b618077343fbbd92b7.ttf":{"createdTime":1767017200401,"modifiedTime":1767017200401,"sourceSize":155288,"sourcePath":"","exportPath":"site-lib/fonts/05b618077343fbbd92b7.ttf","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/4bb6ac751d1c5478ff3a.woff2":{"createdTime":1767017200399,"modifiedTime":1767017200399,"sourceSize":7876,"sourcePath":"","exportPath":"site-lib/fonts/4bb6ac751d1c5478ff3a.woff2","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/media/6155340132a851f6089e.svg":{"createdTime":1767017200399,"modifiedTime":1767017200399,"sourceSize":315,"sourcePath":"","exportPath":"site-lib/media/6155340132a851f6089e.svg","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"site-lib/media/2308ab1944a6bfa5c5b8.svg":{"createdTime":1767017200399,"modifiedTime":1767017200399,"sourceSize":278,"sourcePath":"","exportPath":"site-lib/media/2308ab1944a6bfa5c5b8.svg","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"site-lib/fonts/mathjax_zero.woff":{"createdTime":1767017061262,"modifiedTime":1767017061262,"sourceSize":1368,"sourcePath":"","exportPath":"site-lib/fonts/mathjax_zero.woff","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/mathjax_main-regular.woff":{"createdTime":1767017061262,"modifiedTime":1767017061262,"sourceSize":34160,"sourcePath":"","exportPath":"site-lib/fonts/mathjax_main-regular.woff","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/mathjax_main-bold.woff":{"createdTime":1767017061262,"modifiedTime":1767017061262,"sourceSize":34464,"sourcePath":"","exportPath":"site-lib/fonts/mathjax_main-bold.woff","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/mathjax_math-italic.woff":{"createdTime":1767017061262,"modifiedTime":1767017061262,"sourceSize":19360,"sourcePath":"","exportPath":"site-lib/fonts/mathjax_math-italic.woff","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/mathjax_main-italic.woff":{"createdTime":1767017061262,"modifiedTime":1767017061262,"sourceSize":20832,"sourcePath":"","exportPath":"site-lib/fonts/mathjax_main-italic.woff","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/mathjax_math-bolditalic.woff":{"createdTime":1767017061262,"modifiedTime":1767017061262,"sourceSize":19776,"sourcePath":"","exportPath":"site-lib/fonts/mathjax_math-bolditalic.woff","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/mathjax_size1-regular.woff":{"createdTime":1767017061262,"modifiedTime":1767017061262,"sourceSize":5792,"sourcePath":"","exportPath":"site-lib/fonts/mathjax_size1-regular.woff","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/mathjax_size2-regular.woff":{"createdTime":1767017061262,"modifiedTime":1767017061262,"sourceSize":5464,"sourcePath":"","exportPath":"site-lib/fonts/mathjax_size2-regular.woff","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/mathjax_size3-regular.woff":{"createdTime":1767017061262,"modifiedTime":1767017061262,"sourceSize":3244,"sourcePath":"","exportPath":"site-lib/fonts/mathjax_size3-regular.woff","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/mathjax_size4-regular.woff":{"createdTime":1767017061262,"modifiedTime":1767017061262,"sourceSize":5148,"sourcePath":"","exportPath":"site-lib/fonts/mathjax_size4-regular.woff","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/mathjax_ams-regular.woff":{"createdTime":1767017061262,"modifiedTime":1767017061262,"sourceSize":40808,"sourcePath":"","exportPath":"site-lib/fonts/mathjax_ams-regular.woff","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/mathjax_calligraphic-regular.woff":{"createdTime":1767017061262,"modifiedTime":1767017061262,"sourceSize":9600,"sourcePath":"","exportPath":"site-lib/fonts/mathjax_calligraphic-regular.woff","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/mathjax_calligraphic-bold.woff":{"createdTime":1767017061262,"modifiedTime":1767017061262,"sourceSize":9908,"sourcePath":"","exportPath":"site-lib/fonts/mathjax_calligraphic-bold.woff","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/mathjax_fraktur-regular.woff":{"createdTime":1767017061262,"modifiedTime":1767017061262,"sourceSize":21480,"sourcePath":"","exportPath":"site-lib/fonts/mathjax_fraktur-regular.woff","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/mathjax_fraktur-bold.woff":{"createdTime":1767017061262,"modifiedTime":1767017061262,"sourceSize":22340,"sourcePath":"","exportPath":"site-lib/fonts/mathjax_fraktur-bold.woff","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/mathjax_sansserif-regular.woff":{"createdTime":1767017061262,"modifiedTime":1767017061262,"sourceSize":12660,"sourcePath":"","exportPath":"site-lib/fonts/mathjax_sansserif-regular.woff","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/mathjax_sansserif-bold.woff":{"createdTime":1767017061263,"modifiedTime":1767017061263,"sourceSize":15944,"sourcePath":"","exportPath":"site-lib/fonts/mathjax_sansserif-bold.woff","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/mathjax_sansserif-italic.woff":{"createdTime":1767017061263,"modifiedTime":1767017061263,"sourceSize":14628,"sourcePath":"","exportPath":"site-lib/fonts/mathjax_sansserif-italic.woff","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/mathjax_script-regular.woff":{"createdTime":1767017061263,"modifiedTime":1767017061263,"sourceSize":11852,"sourcePath":"","exportPath":"site-lib/fonts/mathjax_script-regular.woff","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/mathjax_typewriter-regular.woff":{"createdTime":1767017061263,"modifiedTime":1767017061263,"sourceSize":17604,"sourcePath":"","exportPath":"site-lib/fonts/mathjax_typewriter-regular.woff","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/mathjax_vector-regular.woff":{"createdTime":1767017061263,"modifiedTime":1767017061263,"sourceSize":1136,"sourcePath":"","exportPath":"site-lib/fonts/mathjax_vector-regular.woff","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/mathjax_vector-bold.woff":{"createdTime":1767017061263,"modifiedTime":1767017061263,"sourceSize":1116,"sourcePath":"","exportPath":"site-lib/fonts/mathjax_vector-bold.woff","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/html/file-tree-content.html":{"createdTime":1767017200486,"modifiedTime":1767017200486,"sourceSize":2447,"sourcePath":"","exportPath":"site-lib/html/file-tree-content.html","showInTree":false,"treeOrder":0,"backlinks":[],"type":"html","data":null},"site-lib/scripts/webpage.js":{"createdTime":1766971742528,"modifiedTime":1766971742528,"sourceSize":110729,"sourcePath":"","exportPath":"site-lib/scripts/webpage.js","showInTree":false,"treeOrder":0,"backlinks":[],"type":"script","data":null},"site-lib/media/favicon.png":{"createdTime":1767017200341,"modifiedTime":1767017200341,"sourceSize":1105,"sourcePath":"","exportPath":"site-lib/media/favicon.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"site-lib/styles/snippets.css":{"createdTime":1767017200398,"modifiedTime":1767017200398,"sourceSize":279,"sourcePath":"","exportPath":"site-lib/styles/snippets.css","showInTree":false,"treeOrder":0,"backlinks":[],"type":"style","data":null},"site-lib/styles/obsidian.css":{"createdTime":1767017200422,"modifiedTime":1767017200422,"sourceSize":205827,"sourcePath":"","exportPath":"site-lib/styles/obsidian.css","showInTree":false,"treeOrder":0,"backlinks":[],"type":"style","data":null},"site-lib/styles/other-plugins.css":{"createdTime":1766971891350,"modifiedTime":1766971891350,"sourceSize":29565,"sourcePath":"","exportPath":"site-lib/styles/other-plugins.css","showInTree":false,"treeOrder":0,"backlinks":[],"type":"style","data":null},"site-lib/styles/global-variable-styles.css":{"createdTime":1767017200376,"modifiedTime":1767017200376,"sourceSize":305,"sourcePath":"","exportPath":"site-lib/styles/global-variable-styles.css","showInTree":false,"treeOrder":0,"backlinks":[],"type":"style","data":null},"site-lib/styles/supported-plugins.css":{"createdTime":1767017200376,"modifiedTime":1767017200376,"sourceSize":23838,"sourcePath":"","exportPath":"site-lib/styles/supported-plugins.css","showInTree":false,"treeOrder":0,"backlinks":[],"type":"style","data":null},"site-lib/styles/main-styles.css":{"createdTime":1766971742541,"modifiedTime":1766971742541,"sourceSize":19521,"sourcePath":"","exportPath":"site-lib/styles/main-styles.css","showInTree":false,"treeOrder":0,"backlinks":[],"type":"style","data":null},"a9s/screenshot-2025-10-04-at-04.41.40.png":{"createdTime":1759542102286,"modifiedTime":1759542102286,"sourceSize":112137,"sourcePath":"a9s/Screenshot 2025-10-04 at 04.41.40.png","exportPath":"a9s/screenshot-2025-10-04-at-04.41.40.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"a9s/screenshot-2025-10-04-at-20.06.24.png":{"createdTime":1759597586247,"modifiedTime":1759597586247,"sourceSize":72120,"sourcePath":"a9s/Screenshot 2025-10-04 at 20.06.24.png","exportPath":"a9s/screenshot-2025-10-04-at-20.06.24.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"a9s/screenshot-2025-10-05-at-01.00.15.png":{"createdTime":1759615218481,"modifiedTime":1759615218481,"sourceSize":198306,"sourcePath":"a9s/Screenshot 2025-10-05 at 01.00.15.png","exportPath":"a9s/screenshot-2025-10-05-at-01.00.15.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"a9s/screenshot-2025-10-05-at-05.47.03.png":{"createdTime":1759632425379,"modifiedTime":1759632425379,"sourceSize":65434,"sourcePath":"a9s/Screenshot 2025-10-05 at 05.47.03.png","exportPath":"a9s/screenshot-2025-10-05-at-05.47.03.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"a9s/screenshot-2025-10-05-at-18.26.55.png":{"createdTime":1759678018898,"modifiedTime":1759678018899,"sourceSize":299100,"sourcePath":"a9s/Screenshot 2025-10-05 at 18.26.55.png","exportPath":"a9s/screenshot-2025-10-05-at-18.26.55.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"a9s/screenshot-2025-10-05-at-18.27.27.png":{"createdTime":1759678048776,"modifiedTime":1759678048777,"sourceSize":62431,"sourcePath":"a9s/Screenshot 2025-10-05 at 18.27.27.png","exportPath":"a9s/screenshot-2025-10-05-at-18.27.27.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"a9s/screenshot-2025-10-07-at-03.03.28.png":{"createdTime":1759795410655,"modifiedTime":1759795410656,"sourceSize":13776,"sourcePath":"a9s/Screenshot 2025-10-07 at 03.03.28.png","exportPath":"a9s/screenshot-2025-10-07-at-03.03.28.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"a9s/screenshot-2025-10-11-at-19.25.32.png":{"createdTime":1760199934341,"modifiedTime":1760199934342,"sourceSize":87538,"sourcePath":"a9s/Screenshot 2025-10-11 at 19.25.32.png","exportPath":"a9s/screenshot-2025-10-11-at-19.25.32.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"a9s/screenshot-2025-09-27-at-22.49.48.png":{"createdTime":1759002590474,"modifiedTime":1759002590475,"sourceSize":349951,"sourcePath":"a9s/Screenshot 2025-09-27 at 22.49.48.png","exportPath":"a9s/screenshot-2025-09-27-at-22.49.48.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"a9s/screenshot-2025-09-20-at-01.48.06.png":{"createdTime":1758322089034,"modifiedTime":1758322089035,"sourceSize":108370,"sourcePath":"a9s/Screenshot 2025-09-20 at 01.48.06.png","exportPath":"a9s/screenshot-2025-09-20-at-01.48.06.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"a9s/screenshot-2025-09-20-at-13.23.06.png":{"createdTime":1758363789114,"modifiedTime":1758363789114,"sourceSize":156916,"sourcePath":"a9s/Screenshot 2025-09-20 at 13.23.06.png","exportPath":"a9s/screenshot-2025-09-20-at-13.23.06.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"a9s/screenshot-2025-09-20-at-15.44.51.png":{"createdTime":1758372292824,"modifiedTime":1758372292825,"sourceSize":233985,"sourcePath":"a9s/Screenshot 2025-09-20 at 15.44.51.png","exportPath":"a9s/screenshot-2025-09-20-at-15.44.51.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"a9s/screenshot-2025-09-25-at-02.53.33.png":{"createdTime":1758758014598,"modifiedTime":1758758014619,"sourceSize":87168,"sourcePath":"a9s/Screenshot 2025-09-25 at 02.53.33.png","exportPath":"a9s/screenshot-2025-09-25-at-02.53.33.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"a9s/screenshot-2025-09-29-at-04.15.37.png":{"createdTime":1759108540340,"modifiedTime":1759108540340,"sourceSize":55619,"sourcePath":"a9s/Screenshot 2025-09-29 at 04.15.37.png","exportPath":"a9s/screenshot-2025-09-29-at-04.15.37.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"a9s/screenshot-2025-09-29-at-15.56.15.png":{"createdTime":1759150577015,"modifiedTime":1759150577016,"sourceSize":70521,"sourcePath":"a9s/Screenshot 2025-09-29 at 15.56.15.png","exportPath":"a9s/screenshot-2025-09-29-at-15.56.15.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"a9s/screenshot-2025-10-01-at-02.55.34.png":{"createdTime":1759276536942,"modifiedTime":1759276536942,"sourceSize":44944,"sourcePath":"a9s/Screenshot 2025-10-01 at 02.55.34.png","exportPath":"a9s/screenshot-2025-10-01-at-02.55.34.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"a9s/screenshot-2025-10-01-at-02.56.03.png":{"createdTime":1759276564362,"modifiedTime":1759276564363,"sourceSize":65780,"sourcePath":"a9s/Screenshot 2025-10-01 at 02.56.03.png","exportPath":"a9s/screenshot-2025-10-01-at-02.56.03.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"a9s/screenshot-2025-10-02-at-01.51.27.png":{"createdTime":1759359089260,"modifiedTime":1759359089260,"sourceSize":139751,"sourcePath":"a9s/Screenshot 2025-10-02 at 01.51.27.png","exportPath":"a9s/screenshot-2025-10-02-at-01.51.27.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"a9s/screenshot-2025-10-02-at-23.54.37.png":{"createdTime":1759438480681,"modifiedTime":1759438480681,"sourceSize":182910,"sourcePath":"a9s/Screenshot 2025-10-02 at 23.54.37.png","exportPath":"a9s/screenshot-2025-10-02-at-23.54.37.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"site-lib/rss.xml":{"createdTime":1767017210395,"modifiedTime":1767017210395,"sourceSize":173998,"sourcePath":"","exportPath":"site-lib/rss.xml","showInTree":false,"treeOrder":0,"backlinks":[],"type":"other","data":null}},"sourceToTarget":{"engineering/compendium/Kernighan & Ritchie ‚Äî C PL.md":"kernighan-&-ritchie-‚Äî-c-pl.html","engineering/compendium/Start page.md":"start-page.html","engineering/compendium/Stroustrup B./TC++PL. Tome 1.md":"stroustrup-b./tc++pl.-tome-1.html","engineering/compendium/Stroustrup B./TC++PL. Tome 2.md":"stroustrup-b./tc++pl.-tome-2.html","":"site-lib/rss.xml","a9s/Screenshot 2025-10-04 at 04.41.40.png":"a9s/screenshot-2025-10-04-at-04.41.40.png","a9s/Screenshot 2025-10-04 at 20.06.24.png":"a9s/screenshot-2025-10-04-at-20.06.24.png","a9s/Screenshot 2025-10-05 at 01.00.15.png":"a9s/screenshot-2025-10-05-at-01.00.15.png","a9s/Screenshot 2025-10-05 at 05.47.03.png":"a9s/screenshot-2025-10-05-at-05.47.03.png","a9s/Screenshot 2025-10-05 at 18.26.55.png":"a9s/screenshot-2025-10-05-at-18.26.55.png","a9s/Screenshot 2025-10-05 at 18.27.27.png":"a9s/screenshot-2025-10-05-at-18.27.27.png","a9s/Screenshot 2025-10-07 at 03.03.28.png":"a9s/screenshot-2025-10-07-at-03.03.28.png","a9s/Screenshot 2025-10-11 at 19.25.32.png":"a9s/screenshot-2025-10-11-at-19.25.32.png","a9s/Screenshot 2025-09-27 at 22.49.48.png":"a9s/screenshot-2025-09-27-at-22.49.48.png","a9s/Screenshot 2025-09-20 at 01.48.06.png":"a9s/screenshot-2025-09-20-at-01.48.06.png","a9s/Screenshot 2025-09-20 at 13.23.06.png":"a9s/screenshot-2025-09-20-at-13.23.06.png","a9s/Screenshot 2025-09-20 at 15.44.51.png":"a9s/screenshot-2025-09-20-at-15.44.51.png","a9s/Screenshot 2025-09-25 at 02.53.33.png":"a9s/screenshot-2025-09-25-at-02.53.33.png","a9s/Screenshot 2025-09-29 at 04.15.37.png":"a9s/screenshot-2025-09-29-at-04.15.37.png","a9s/Screenshot 2025-09-29 at 15.56.15.png":"a9s/screenshot-2025-09-29-at-15.56.15.png","a9s/Screenshot 2025-10-01 at 02.55.34.png":"a9s/screenshot-2025-10-01-at-02.55.34.png","a9s/Screenshot 2025-10-01 at 02.56.03.png":"a9s/screenshot-2025-10-01-at-02.56.03.png","a9s/Screenshot 2025-10-02 at 01.51.27.png":"a9s/screenshot-2025-10-02-at-01.51.27.png","a9s/Screenshot 2025-10-02 at 23.54.37.png":"a9s/screenshot-2025-10-02-at-23.54.37.png"},"featureOptions":{"backlinks":{"featureId":"backlinks","enabled":true,"unavailable":false,"alwaysEnabled":false,"hideSettingsButton":false,"featurePlacement":{"selector":".footer","type":"start","info_selector":{"show":true,"name":"","description":"CSS selector for an element. The feature will be placed relative to this element.","placeholder":""},"info_type":{"show":true,"name":"","description":"Will this feature be placed before, after, or inside (at the beggining or end).","placeholder":"","dropdownOptions":{"Before":"before","After":"after","Start":"start","End":"end"}}},"info_featurePlacement":{"show":true,"name":"","description":"Where to place this feature on the page. (Relative to the selector)","placeholder":""},"displayTitle":"Backlinks","info_displayTitle":{"show":true,"name":"","description":"Descriptive title to show above the feature","placeholder":""}},"tags":{"featureId":"tags","enabled":true,"unavailable":false,"alwaysEnabled":false,"hideSettingsButton":false,"featurePlacement":{"selector":".header .data-bar","type":"end","info_selector":{"show":true,"name":"","description":"CSS selector for an element. The feature will be placed relative to this element.","placeholder":""},"info_type":{"show":true,"name":"","description":"Will this feature be placed before, after, or inside (at the beggining or end).","placeholder":"","dropdownOptions":{"Before":"before","After":"after","Start":"start","End":"end"}}},"info_featurePlacement":{"show":true,"name":"","description":"Where to place this feature on the page. (Relative to the selector)","placeholder":""},"displayTitle":"","info_displayTitle":{"show":true,"name":"","description":"Descriptive title to show above the feature","placeholder":""},"showInlineTags":true,"showFrontmatterTags":true,"info_showInlineTags":{"show":true,"name":"","description":"Show tags defined inside the document at the top of the page.","placeholder":""},"info_showFrontmatterTags":{"show":true,"name":"","description":"Show tags defined in the frontmatter of the document at the top of the page.","placeholder":""}},"alias":{"featureId":"aliases","enabled":true,"unavailable":false,"alwaysEnabled":false,"hideSettingsButton":false,"featurePlacement":{"selector":".header .data-bar","type":"start","info_selector":{"show":true,"name":"","description":"CSS selector for an element. The feature will be placed relative to this element.","placeholder":""},"info_type":{"show":true,"name":"","description":"Will this feature be placed before, after, or inside (at the beggining or end).","placeholder":"","dropdownOptions":{"Before":"before","After":"after","Start":"start","End":"end"}}},"info_featurePlacement":{"show":true,"name":"","description":"Where to place this feature on the page. (Relative to the selector)","placeholder":""},"displayTitle":"Aliases","info_displayTitle":{"show":true,"name":"","description":"Descriptive title to show above the feature","placeholder":""}},"properties":{"featureId":"properties","enabled":true,"unavailable":false,"alwaysEnabled":false,"hideSettingsButton":false,"featurePlacement":{"selector":".header","type":"start","info_selector":{"show":true,"name":"","description":"CSS selector for an element. The feature will be placed relative to this element.","placeholder":""},"info_type":{"show":true,"name":"","description":"Will this feature be placed before, after, or inside (at the beggining or end).","placeholder":"","dropdownOptions":{"Before":"before","After":"after","Start":"start","End":"end"}}},"info_featurePlacement":{"show":true,"name":"","description":"Where to place this feature on the page. (Relative to the selector)","placeholder":""},"displayTitle":"Properties","info_displayTitle":{"show":true,"name":"","description":"Descriptive title to show above the feature","placeholder":""},"info_hideProperties":{"show":true,"name":"","description":"A list of properties to hide from the properties view","placeholder":""}},"fileNavigation":{"featureId":"file-navigation","enabled":true,"unavailable":false,"alwaysEnabled":false,"hideSettingsButton":false,"featurePlacement":{"selector":"#left-sidebar-content","type":"end","info_selector":{"show":true,"name":"","description":"CSS selector for an element. The feature will be placed relative to this element.","placeholder":""},"info_type":{"show":true,"name":"","description":"Will this feature be placed before, after, or inside (at the beggining or end).","placeholder":"","dropdownOptions":{"Before":"before","After":"after","Start":"start","End":"end"}}},"info_featurePlacement":{"show":true,"name":"","description":"Where to place this feature on the page. (Relative to the selector)","placeholder":""},"info_includePath":{"show":false,"name":"","description":"","placeholder":""},"showCustomIcons":false,"showDefaultFolderIcons":false,"showDefaultFileIcons":false,"defaultFolderIcon":"lucide//folder","defaultFileIcon":"lucide//file","defaultMediaIcon":"lucide//file-image","exposeStartingPath":true,"info_showCustomIcons":{"show":true,"name":"","description":"Show custom icons for files and folders","placeholder":""},"info_showDefaultFolderIcons":{"show":true,"name":"","description":"Show a default icon of a folder for every folder in the tree","placeholder":""},"info_showDefaultFileIcons":{"show":true,"name":"","description":"Show a default icon of a file for every file in the tree","placeholder":""},"info_defaultFolderIcon":{"show":true,"name":"","description":"The icon to use for folders. Prefix with 'lucide//' to use a Lucide icon","placeholder":""},"info_defaultFileIcon":{"show":true,"name":"","description":"The icon to use for files. Prefix with 'lucide//' to use a Lucide icon","placeholder":""},"info_defaultMediaIcon":{"show":true,"name":"","description":"The icon to use for media files. Prefix with 'lucide//' to use a Lucide icon","placeholder":""},"info_exposeStartingPath":{"show":true,"name":"","description":"Whether or not to show the current file in the file tree when the page is first loaded","placeholder":""},"includePath":"site-lib/html/file-tree.html"},"search":{"featureId":"search","enabled":true,"unavailable":false,"alwaysEnabled":false,"hideSettingsButton":false,"featurePlacement":{"selector":"#left-sidebar .topbar-content","type":"start","info_selector":{"show":true,"name":"","description":"CSS selector for an element. The feature will be placed relative to this element.","placeholder":""},"info_type":{"show":true,"name":"","description":"Will this feature be placed before, after, or inside (at the beggining or end).","placeholder":"","dropdownOptions":{"Before":"before","After":"after","Start":"start","End":"end"}}},"info_featurePlacement":{"show":true,"name":"","description":"Where to place this feature on the page. (Relative to the selector)","placeholder":""},"displayTitle":"Search...","info_displayTitle":{"show":true,"name":"","description":"Descriptive title to show above the feature","placeholder":""}},"outline":{"featureId":"outline","enabled":true,"unavailable":false,"alwaysEnabled":false,"hideSettingsButton":false,"featurePlacement":{"selector":"#right-sidebar-content","type":"end","info_selector":{"show":true,"name":"","description":"CSS selector for an element. The feature will be placed relative to this element.","placeholder":""},"info_type":{"show":true,"name":"","description":"Will this feature be placed before, after, or inside (at the beggining or end).","placeholder":"","dropdownOptions":{"Before":"before","After":"after","Start":"start","End":"end"}}},"info_featurePlacement":{"show":true,"name":"","description":"Where to place this feature on the page. (Relative to the selector)","placeholder":""},"displayTitle":"Outline","info_displayTitle":{"show":true,"name":"","description":"Descriptive title to show above the feature","placeholder":""},"startCollapsed":false,"minCollapseDepth":0,"info_startCollapsed":{"show":true,"name":"","description":"Should the outline start collapsed?","placeholder":""},"info_minCollapseDepth":{"show":true,"name":"","description":"Only allow outline items to be collapsed if they are at least this many levels deep in the tree.","placeholder":"","dropdownOptions":{"1":1,"2":2,"No Collapse":100}}},"themeToggle":{"featureId":"theme-toggle","enabled":true,"unavailable":false,"alwaysEnabled":false,"hideSettingsButton":false,"featurePlacement":{"selector":"#right-sidebar .topbar-content","type":"start","info_selector":{"show":true,"name":"","description":"CSS selector for an element. The feature will be placed relative to this element.","placeholder":""},"info_type":{"show":true,"name":"","description":"Will this feature be placed before, after, or inside (at the beggining or end).","placeholder":"","dropdownOptions":{"Before":"before","After":"after","Start":"start","End":"end"}}},"info_featurePlacement":{"show":true,"name":"","description":"Where to place this feature on the page. (Relative to the selector)","placeholder":""},"displayTitle":"","info_displayTitle":{"show":true,"name":"","description":"Descriptive title to show above the feature","placeholder":""}},"graphView":{"featureId":"graph-view","enabled":false,"unavailable":false,"alwaysEnabled":false,"hideSettingsButton":false,"featurePlacement":{"selector":"#right-sidebar-content","type":"start","info_selector":{"show":true,"name":"","description":"CSS selector for an element. The feature will be placed relative to this element.","placeholder":""},"info_type":{"show":true,"name":"","description":"Will this feature be placed before, after, or inside (at the beggining or end).","placeholder":"","dropdownOptions":{"Before":"before","After":"after","Start":"start","End":"end"}}},"info_featurePlacement":{"show":true,"name":"","description":"Where to place this feature on the page. (Relative to the selector)","placeholder":""},"displayTitle":"Graph View","info_displayTitle":{"show":true,"name":"","description":"Descriptive title to show above the feature","placeholder":""},"showOrphanNodes":true,"showAttachments":false,"allowGlobalGraph":true,"allowExpand":true,"attractionForce":1,"linkLength":15,"repulsionForce":80,"centralForce":2,"edgePruning":100,"minNodeRadius":3,"maxNodeRadius":7,"info_showOrphanNodes":{"show":true,"name":"","description":"Show nodes that are not connected to any other nodes.","placeholder":""},"info_showAttachments":{"show":true,"name":"","description":"Show attachments like images and PDFs as nodes in the graph.","placeholder":""},"info_allowGlobalGraph":{"show":true,"name":"","description":"Allow the user to view the global graph of all nodes.","placeholder":""},"info_allowExpand":{"show":true,"name":"","description":"Allow the user to pop-out the graph view to take up the whole screen","placeholder":""},"info_attractionForce":{"show":true,"name":"","description":"How much should linked nodes attract each other? This will make the graph appear more clustered.","placeholder":""},"info_linkLength":{"show":true,"name":"","description":"How long should the links between nodes be? The shorter the links the more connected nodes will cluster together.","placeholder":""},"info_repulsionForce":{"show":true,"name":"","description":"How much should nodes repel each other? This will make disconnected parts more spread out.","placeholder":""},"info_centralForce":{"show":true,"name":"","description":"How much should nodes be attracted to the center? This will make the graph appear more dense and circular.","placeholder":""},"info_edgePruning":{"show":true,"name":"","description":"Edges with a length above this threshold will not be rendered, however they will still contribute to the simulation. This can help large tangled graphs look more organised. Hovering over a node will still display these links.","placeholder":""},"info_minNodeRadius":{"show":true,"name":"","description":"How small should the smallest nodes be? The smaller a node is the less it will attract other nodes.","placeholder":""},"info_maxNodeRadius":{"show":true,"name":"","description":"How large should the largest nodes be? Nodes are sized by how many links they have. The larger a node is the more it will attract other nodes. This can be used to create a good grouping around the most important nodes.","placeholder":""}},"sidebar":{"featureId":"sidebar","enabled":true,"unavailable":false,"alwaysEnabled":false,"hideSettingsButton":false,"allowResizing":true,"allowCollapsing":true,"rightDefaultWidth":"20em","leftDefaultWidth":"20em","info_allowResizing":{"show":true,"name":"","description":"Whether or not to allow the sidebars to be resized","placeholder":""},"info_allowCollapsing":{"show":true,"name":"","description":"Whether or not to allow the sidebars to be collapsed","placeholder":""},"info_rightDefaultWidth":{"show":true,"name":"","description":"The default width of the right sidebar","placeholder":""},"info_leftDefaultWidth":{"show":true,"name":"","description":"The default width of the left sidebar","placeholder":""}},"customHead":{"featureId":"custom-head","enabled":true,"unavailable":false,"alwaysEnabled":false,"hideSettingsButton":false,"featurePlacement":{"selector":"head","type":"end","info_selector":{"show":true,"name":"","description":"CSS selector for an element. The feature will be placed relative to this element.","placeholder":""},"info_type":{"show":true,"name":"","description":"Will this feature be placed before, after, or inside (at the beggining or end).","placeholder":"","dropdownOptions":{"Before":"before","After":"after","Start":"start","End":"end"}}},"info_featurePlacement":{"show":true,"name":"","description":"Where to place this feature on the page. (Relative to the selector)","placeholder":""},"info_includePath":{"show":false,"name":"","description":"","placeholder":""},"sourcePath":"","info_sourcePath":{"show":true,"name":"","description":"The local path to the source .html file which will be included.","placeholder":"","fileInputOptions":{"makeRelativeToVault":true,"browseButton":true}},"includePath":"site-lib/html/custom-head.html"},"document":{"featureId":"obsidian-document","enabled":true,"unavailable":false,"alwaysEnabled":true,"hideSettingsButton":false,"allowFoldingLists":true,"allowFoldingHeadings":true,"documentWidth":"40em","info_allowFoldingLists":{"show":true,"name":"","description":"Whether or not to allow lists to be folded","placeholder":""},"info_allowFoldingHeadings":{"show":true,"name":"","description":"Whether or not to allow headings to be folded","placeholder":""},"info_documentWidth":{"show":true,"name":"","description":"The width of the document","placeholder":""}},"rss":{"featureId":"rss","enabled":true,"unavailable":false,"alwaysEnabled":false,"hideSettingsButton":false,"siteUrl":"","authorName":"","info_siteUrl":{"show":true,"name":"","description":"The url that this site will be hosted at","placeholder":"https://example.com/mysite"},"info_authorName":{"show":true,"name":"","description":"The name of the author of the site","placeholder":""}},"linkPreview":{"featureId":"link-preview","enabled":true,"unavailable":false,"alwaysEnabled":false,"hideSettingsButton":true}},"modifiedTime":1767017200423,"siteName":"Compendium","vaultName":"Vault","exportRoot":"engineering/compendium","baseURL":"","pluginVersion":"1.9.2","themeName":"","bodyClasses":"publish css-settings-manager show-inline-title show-ribbon code-styler code-styler-style-inline code-styler-gutter-highlight center-latex-figures invert-latex-figures is-focused","hasFavicon":false}